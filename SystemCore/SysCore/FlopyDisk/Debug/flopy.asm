; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Ali\Desktop\MangOS\SystemCore\SysCore\FlopyDisk\flopy.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?DMA_BUFFER@@3HA				; DMA_BUFFER
_BSS	SEGMENT
__CurrentDrive DB 01H DUP (?)
__FloppyDiskIRQ DB 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
?DMA_BUFFER@@3HA DD 01000H				; DMA_BUFFER
_DATA	ENDS
PUBLIC	?flpydsk_set_dma@@YAXH@Z			; flpydsk_set_dma
PUBLIC	?flpydsk_install@@YAXH@Z			; flpydsk_install
PUBLIC	?flpydsk_set_working_drive@@YAXE@Z		; flpydsk_set_working_drive
PUBLIC	?flpydsk_get_working_drive@@YAEXZ		; flpydsk_get_working_drive
PUBLIC	?flpydsk_read_sector@@YAPAEH@Z			; flpydsk_read_sector
PUBLIC	?flpydsk_lba_to_chs@@YAXHPAH00@Z		; flpydsk_lba_to_chs
PUBLIC	?dma_initialize_floppy@@YA_NPAEI@Z		; dma_initialize_floppy
PUBLIC	?flpydsk_read_status@@YAEXZ			; flpydsk_read_status
PUBLIC	?flpydsk_write_dor@@YAXE@Z			; flpydsk_write_dor
PUBLIC	?flpydsk_send_command@@YAXE@Z			; flpydsk_send_command
PUBLIC	?flpydsk_read_data@@YAEXZ			; flpydsk_read_data
PUBLIC	?flpydsk_write_ccr@@YAXE@Z			; flpydsk_write_ccr
PUBLIC	?flpydsk_wait_irq@@YAXXZ			; flpydsk_wait_irq
PUBLIC	?i86_flpy_irq@@YAXXZ				; i86_flpy_irq
PUBLIC	?flpydsk_check_int@@YAXPAI0@Z			; flpydsk_check_int
PUBLIC	?flpydsk_control_motor@@YAX_N@Z			; flpydsk_control_motor
PUBLIC	?flpydsk_drive_data@@YAXEEE_N@Z			; flpydsk_drive_data
PUBLIC	?flpydsk_calibrate@@YAHE@Z			; flpydsk_calibrate
PUBLIC	?flpydsk_disable_controller@@YAXXZ		; flpydsk_disable_controller
PUBLIC	?flpydsk_enable_controller@@YAXXZ		; flpydsk_enable_controller
PUBLIC	?flpydsk_reset@@YAXXZ				; flpydsk_reset
PUBLIC	?flpydsk_read_sector_imp@@YAXEEE@Z		; flpydsk_read_sector_imp
PUBLIC	?flpydsk_seek@@YAHEE@Z				; flpydsk_seek
EXTRN	?outportb@@YAXGE@Z:PROC				; outportb
EXTRN	?inportb@@YAEG@Z:PROC				; inportb
EXTRN	?setvect@@YAXIA6AXXZ@Z:PROC			; setvect
EXTRN	?intdone@@YAXE@Z:PROC				; intdone
EXTRN	?dma_set_read@@YAXE@Z:PROC			; dma_set_read
EXTRN	?dma_set_address@@YAXEEE@Z:PROC			; dma_set_address
EXTRN	?dma_set_count@@YAXEEE@Z:PROC			; dma_set_count
EXTRN	?dma_mask_channel@@YAXE@Z:PROC			; dma_mask_channel
EXTRN	?dma_reset_flipflop@@YAXH@Z:PROC		; dma_reset_flipflop
EXTRN	?dma_reset@@YAXH@Z:PROC				; dma_reset
EXTRN	?dma_unmask_all@@YAXH@Z:PROC			; dma_unmask_all
EXTRN	?sleep@@YAXH@Z:PROC				; sleep
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_cmd$ = -12						; size = 1
_cyl0$ = -8						; size = 4
_st0$ = -4						; size = 4
_cyl$ = 8						; size = 1
_head$ = 12						; size = 1
?flpydsk_seek@@YAHEE@Z PROC				; flpydsk_seek

; 481  : int flpydsk_seek(uint8_t cyl, uint8_t head) {

	sub	esp, 12					; 0000000cH

; 482  : 
; 483  : 	uint32_t st0, cyl0;
; 484  : 
; 485  : 	if (_CurrentDrive >= 4)

	cmp	BYTE PTR __CurrentDrive, 4
	jb	SHORT $LN5@flpydsk_se

; 486  : 		return -1;

	or	eax, -1

; 505  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN5@flpydsk_se:
	push	ebx
	mov	ebx, DWORD PTR _cyl$[esp+12]
	push	ebp
	push	edi

; 487  : 
; 488  : 	for (int i = 0; i < 10; i++) {

	xor	edi, edi
	movzx	ebp, bl
	shl	BYTE PTR _head$[esp+20], 2
	push	esi
	npad	11
$LL4@flpydsk_se:

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL11@flpydsk_se:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN41@flpydsk_se

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL11@flpydsk_se

; 498  : 
; 499  : 		//! found the cylinder?
; 500  : 		if (cyl0 == cyl)

	jmp	SHORT $LN9@flpydsk_se
$LN41@flpydsk_se:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	15					; 0000000fH
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN9@flpydsk_se:

; 489  : 
; 490  : 		//! send the command
; 491  : 		flpydsk_send_command(FDC_CMD_SEEK);
; 492  : 		flpydsk_send_command((head) << 2 | _CurrentDrive);

	mov	al, BYTE PTR _head$[esp+24]
	or	al, BYTE PTR __CurrentDrive

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi

; 489  : 
; 490  : 		//! send the command
; 491  : 		flpydsk_send_command(FDC_CMD_SEEK);
; 492  : 		flpydsk_send_command((head) << 2 | _CurrentDrive);

	mov	BYTE PTR _cmd$[esp+28], al
	npad	3
$LL19@flpydsk_se:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN42@flpydsk_se

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL19@flpydsk_se

; 498  : 
; 499  : 		//! found the cylinder?
; 500  : 		if (cyl0 == cyl)

	jmp	SHORT $LN17@flpydsk_se
$LN42@flpydsk_se:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	DWORD PTR _cmd$[esp+28]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN17@flpydsk_se:

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
	npad	1
$LL27@flpydsk_se:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN43@flpydsk_se

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL27@flpydsk_se

; 498  : 
; 499  : 		//! found the cylinder?
; 500  : 		if (cyl0 == cyl)

	jmp	SHORT $LL33@flpydsk_se
$LN43@flpydsk_se:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	ebx
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
	npad	6
$LL33@flpydsk_se:

; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)
; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)
; 273  : 			return inportb(FLPYDSK_FIFO);
; 274  : 
; 275  : 	return 0;
; 276  : }
; 277  : 
; 278  : //! write to the configuation control register
; 279  : void flpydsk_write_ccr(uint8_t val) {
; 280  : 
; 281  : 	//! write the configuation control
; 282  : 	outportb(FLPYDSK_CTRL, val);
; 283  : }
; 284  : 
; 285  : /**
; 286  : *	Interrupt Handling Routines
; 287  : */
; 288  : 
; 289  : //! wait for irq to fire
; 290  : inline void flpydsk_wait_irq() {
; 291  : 
; 292  : 	//! wait for irq to fire
; 293  : 	while (_FloppyDiskIRQ == 0)

	cmp	BYTE PTR __FloppyDiskIRQ, 0
	je	SHORT $LL33@flpydsk_se

; 493  : 		flpydsk_send_command(cyl);
; 494  : 
; 495  : 		//! wait for the results phase IRQ
; 496  : 		flpydsk_wait_irq();
; 497  : 		flpydsk_check_int(&st0, &cyl0);

	lea	eax, DWORD PTR _cyl0$[esp+28]

; 294  : 		;
; 295  : 	_FloppyDiskIRQ = 0;

	mov	BYTE PTR __FloppyDiskIRQ, 0

; 493  : 		flpydsk_send_command(cyl);
; 494  : 
; 495  : 		//! wait for the results phase IRQ
; 496  : 		flpydsk_wait_irq();
; 497  : 		flpydsk_check_int(&st0, &cyl0);

	push	eax
	lea	eax, DWORD PTR _st0$[esp+32]
	push	eax
	call	?flpydsk_check_int@@YAXPAI0@Z		; flpydsk_check_int
	add	esp, 8

; 498  : 
; 499  : 		//! found the cylinder?
; 500  : 		if (cyl0 == cyl)

	cmp	DWORD PTR _cyl0$[esp+28], ebp
	je	SHORT $LN44@flpydsk_se

; 487  : 
; 488  : 	for (int i = 0; i < 10; i++) {

	inc	edi
	cmp	edi, 10					; 0000000aH
	jl	$LL4@flpydsk_se

; 502  : 	}
; 503  : 
; 504  : 	return -1;

	pop	esi
	pop	edi
	pop	ebp
	or	eax, -1
	pop	ebx

; 505  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN44@flpydsk_se:
	pop	esi
	pop	edi
	pop	ebp

; 501  : 			return 0;

	xor	eax, eax
	pop	ebx

; 505  : }

	add	esp, 12					; 0000000cH
	ret	0
?flpydsk_seek@@YAHEE@Z ENDP				; flpydsk_seek
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_head$ = 8						; size = 1
_cmd$ = 8						; size = 1
_cyl$ = 8						; size = 4
_track$ = 12						; size = 1
_sector$ = 16						; size = 1
_st0$ = 16						; size = 4
?flpydsk_read_sector_imp@@YAXEEE@Z PROC			; flpydsk_read_sector_imp

; 447  : void flpydsk_read_sector_imp(uint8_t head, uint8_t track, uint8_t sector) {

	push	esi
	push	edi

; 448  : 
; 449  : 	uint32_t st0, cyl;
; 450  : 
; 451  : 	//! initialize DMA
; 452  : 	dma_initialize_floppy((uint8_t*)DMA_BUFFER, 512);

	push	512					; 00000200H
	push	DWORD PTR ?DMA_BUFFER@@3HA		; DMA_BUFFER
	call	?dma_initialize_floppy@@YA_NPAEI@Z	; dma_initialize_floppy

; 453  : 
; 454  : 	//! set the DMA for read transfer
; 455  : 	dma_set_read(FDC_DMA_CHANNEL);

	push	2
	call	?dma_set_read@@YAXE@Z			; dma_set_read
	add	esp, 12					; 0000000cH

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
	npad	2
$LL11@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN104@flpydsk_re

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL11@flpydsk_re

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN9@flpydsk_re
$LN104@flpydsk_re:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	230					; 000000e6H
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN9@flpydsk_re:
	push	ebx

; 456  : 
; 457  : 	//! read in a sector
; 458  : 	flpydsk_send_command(
; 459  : 		FDC_CMD_READ_SECT | FDC_CMD_EXT_MULTITRACK | FDC_CMD_EXT_SKIP | FDC_CMD_EXT_DENSITY);
; 460  : 	flpydsk_send_command(head << 2 | _CurrentDrive);

	mov	ebx, DWORD PTR _head$[esp+8]
	mov	al, bl
	shl	al, 2
	or	al, BYTE PTR __CurrentDrive

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi

; 456  : 
; 457  : 	//! read in a sector
; 458  : 	flpydsk_send_command(
; 459  : 		FDC_CMD_READ_SECT | FDC_CMD_EXT_MULTITRACK | FDC_CMD_EXT_SKIP | FDC_CMD_EXT_DENSITY);
; 460  : 	flpydsk_send_command(head << 2 | _CurrentDrive);

	mov	BYTE PTR _cmd$[esp+8], al
$LL19@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN105@flpydsk_re

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL19@flpydsk_re

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN17@flpydsk_re
$LN105@flpydsk_re:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	DWORD PTR _cmd$[esp+8]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN17@flpydsk_re:

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL27@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN106@flpydsk_re

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL27@flpydsk_re

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN25@flpydsk_re
$LN106@flpydsk_re:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	DWORD PTR _track$[esp+8]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN25@flpydsk_re:

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL35@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN107@flpydsk_re

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL35@flpydsk_re

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN33@flpydsk_re
$LN107@flpydsk_re:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	ebx
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN33@flpydsk_re:

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
	npad	2
$LL43@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	mov	ebx, DWORD PTR _sector$[esp+12]

; 248  : 	return inportb(FLPYDSK_MSR);

	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN108@flpydsk_re

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL43@flpydsk_re

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN41@flpydsk_re
$LN108@flpydsk_re:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	ebx
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN41@flpydsk_re:

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL51@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN109@flpydsk_re

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL51@flpydsk_re

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN49@flpydsk_re
$LN109@flpydsk_re:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	2
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN49@flpydsk_re:

; 461  : 	flpydsk_send_command(track);
; 462  : 	flpydsk_send_command(head);
; 463  : 	flpydsk_send_command(sector);
; 464  : 	flpydsk_send_command(FLPYDSK_SECTOR_DTL_512);
; 465  : 	flpydsk_send_command(((sector + 1) >= FLPY_SECTORS_PER_TRACK) ? FLPY_SECTORS_PER_TRACK : sector + 1);

	movzx	edi, bl
	mov	eax, 18					; 00000012H
	inc	edi
	cmp	edi, eax
	pop	ebx
	cmovge	edi, eax

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
	npad	4
$LL59@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN110@flpydsk_re

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL59@flpydsk_re

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN57@flpydsk_re
$LN110@flpydsk_re:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	edi
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN57@flpydsk_re:

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
	npad	4
$LL67@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN111@flpydsk_re

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL67@flpydsk_re

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN65@flpydsk_re
$LN111@flpydsk_re:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	27					; 0000001bH
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN65@flpydsk_re:

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
	npad	3
$LL75@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN112@flpydsk_re

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL75@flpydsk_re

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LL81@flpydsk_re
$LN112@flpydsk_re:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	255					; 000000ffH
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
	npad	2
$LL81@flpydsk_re:

; 274  : 
; 275  : 	return 0;
; 276  : }
; 277  : 
; 278  : //! write to the configuation control register
; 279  : void flpydsk_write_ccr(uint8_t val) {
; 280  : 
; 281  : 	//! write the configuation control
; 282  : 	outportb(FLPYDSK_CTRL, val);
; 283  : }
; 284  : 
; 285  : /**
; 286  : *	Interrupt Handling Routines
; 287  : */
; 288  : 
; 289  : //! wait for irq to fire
; 290  : inline void flpydsk_wait_irq() {
; 291  : 
; 292  : 	//! wait for irq to fire
; 293  : 	while (_FloppyDiskIRQ == 0)

	cmp	BYTE PTR __FloppyDiskIRQ, 0
	je	SHORT $LL81@flpydsk_re

; 294  : 		;
; 295  : 	_FloppyDiskIRQ = 0;

	mov	BYTE PTR __FloppyDiskIRQ, 0
	mov	edi, 7
	npad	11
$LL3@flpydsk_re:

; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL87@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN113@flpydsk_re

; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL87@flpydsk_re

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN2@flpydsk_re
$LN113@flpydsk_re:

; 273  : 			return inportb(FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN2@flpydsk_re:

; 466  : 	flpydsk_send_command(FLPYDSK_GAP3_LENGTH_3_5);
; 467  : 	flpydsk_send_command(0xff);
; 468  : 
; 469  : 	//! wait for irq
; 470  : 	flpydsk_wait_irq();
; 471  : 
; 472  : 	//! read status info
; 473  : 	for (int j = 0; j<7; j++)

	dec	edi
	jne	SHORT $LL3@flpydsk_re

; 474  : 		flpydsk_read_data();
; 475  : 
; 476  : 	//! let FDC know we handled interrupt
; 477  : 	flpydsk_check_int(&st0, &cyl);

	lea	eax, DWORD PTR _cyl$[esp+4]
	push	eax
	lea	eax, DWORD PTR _st0$[esp+8]
	push	eax
	call	?flpydsk_check_int@@YAXPAI0@Z		; flpydsk_check_int
	add	esp, 8
	pop	edi
	pop	esi

; 478  : }

	ret	0
?flpydsk_read_sector_imp@@YAXEEE@Z ENDP			; flpydsk_read_sector_imp
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_cyl$ = -8						; size = 4
_st0$ = -4						; size = 4
?flpydsk_reset@@YAXXZ PROC				; flpydsk_reset

; 423  : void flpydsk_reset() {

	sub	esp, 8

; 255  : 	outportb(FLPYDSK_DOR, val);

	push	0
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	push	12					; 0000000cH
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 16					; 00000010H
	npad	2
$LL15@flpydsk_re:

; 283  : }
; 284  : 
; 285  : /**
; 286  : *	Interrupt Handling Routines
; 287  : */
; 288  : 
; 289  : //! wait for irq to fire
; 290  : inline void flpydsk_wait_irq() {
; 291  : 
; 292  : 	//! wait for irq to fire
; 293  : 	while (_FloppyDiskIRQ == 0)

	cmp	BYTE PTR __FloppyDiskIRQ, 0
	je	SHORT $LL15@flpydsk_re
	push	esi

; 294  : 		;
; 295  : 	_FloppyDiskIRQ = 0;

	mov	BYTE PTR __FloppyDiskIRQ, 0
	mov	esi, 4
$LL3@flpydsk_re:

; 424  : 
; 425  : 	uint32_t st0, cyl;
; 426  : 
; 427  : 	//! reset the controller
; 428  : 	flpydsk_disable_controller();
; 429  : 	flpydsk_enable_controller();
; 430  : 	flpydsk_wait_irq();
; 431  : 
; 432  : 	//! send CHECK_INT/SENSE INTERRUPT command to all drives
; 433  : 	for (int i = 0; i<4; i++)
; 434  : 		flpydsk_check_int(&st0, &cyl);

	lea	eax, DWORD PTR _cyl$[esp+12]
	push	eax
	lea	eax, DWORD PTR _st0$[esp+16]
	push	eax
	call	?flpydsk_check_int@@YAXPAI0@Z		; flpydsk_check_int
	add	esp, 8
	dec	esi
	jne	SHORT $LL3@flpydsk_re

; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)
; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)
; 264  : 			return outportb(FLPYDSK_FIFO, cmd);
; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)
; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)
; 273  : 			return inportb(FLPYDSK_FIFO);
; 274  : 
; 275  : 	return 0;
; 276  : }
; 277  : 
; 278  : //! write to the configuation control register
; 279  : void flpydsk_write_ccr(uint8_t val) {
; 280  : 
; 281  : 	//! write the configuation control
; 282  : 	outportb(FLPYDSK_CTRL, val);

	push	esi
	push	1015					; 000003f7H
	call	?outportb@@YAXGE@Z			; outportb

; 435  : 
; 436  : 	//! transfer speed 500kb/s
; 437  : 	flpydsk_write_ccr(0);
; 438  : 
; 439  : 	//! pass mechanical drive info. steprate=3ms, unload time=240ms, load time=16ms
; 440  : 	flpydsk_drive_data(3, 16, 240, true);

	push	1
	push	240					; 000000f0H
	push	16					; 00000010H
	push	3
	call	?flpydsk_drive_data@@YAXEEE_N@Z		; flpydsk_drive_data

; 441  : 
; 442  : 	//! calibrate the disk
; 443  : 	flpydsk_calibrate(_CurrentDrive);

	movzx	eax, BYTE PTR __CurrentDrive
	push	eax
	call	?flpydsk_calibrate@@YAHE@Z		; flpydsk_calibrate
	add	esp, 28					; 0000001cH
	pop	esi

; 444  : }

	add	esp, 8
	ret	0
?flpydsk_reset@@YAXXZ ENDP				; flpydsk_reset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
?flpydsk_enable_controller@@YAXXZ PROC			; flpydsk_enable_controller

; 255  : 	outportb(FLPYDSK_DOR, val);

	push	12					; 0000000cH
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8

; 418  : 
; 419  : 	flpydsk_write_dor(FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA);
; 420  : }

	ret	0
?flpydsk_enable_controller@@YAXXZ ENDP			; flpydsk_enable_controller
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
?flpydsk_disable_controller@@YAXXZ PROC			; flpydsk_disable_controller

; 255  : 	outportb(FLPYDSK_DOR, val);

	push	0
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8

; 412  : 
; 413  : 	flpydsk_write_dor(0);
; 414  : }

	ret	0
?flpydsk_disable_controller@@YAXXZ ENDP			; flpydsk_disable_controller
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_st0$ = -4						; size = 4
tv226 = 8						; size = 4
_drive$ = 8						; size = 1
_cyl$ = 8						; size = 4
?flpydsk_calibrate@@YAHE@Z PROC				; flpydsk_calibrate

; 380  : int flpydsk_calibrate(uint8_t drive) {

	push	ecx
	push	ebx

; 381  : 
; 382  : 	uint32_t st0, cyl;
; 383  : 
; 384  : 	if (drive >= 4)

	mov	ebx, DWORD PTR _drive$[esp+4]
	cmp	bl, 4
	jb	SHORT $LN5@flpydsk_ca

; 385  : 		return -2;

	mov	eax, -2					; fffffffeH
	pop	ebx

; 408  : }

	pop	ecx
	ret	0
$LN5@flpydsk_ca:

; 296  : }
; 297  : 
; 298  : 
; 299  : //!	floppy disk irq handler
; 300  : void _cdecl i86_flpy_irq() {
; 301  : 
; 302  : 	_asm add esp, 12
; 303  : 	_asm pushad
; 304  : 	_asm cli
; 305  : 
; 306  : 	//! irq fired
; 307  : 	_FloppyDiskIRQ = 1;
; 308  : 
; 309  : 	//! tell hal we are done
; 310  : 	intdone(FLOPPY_IRQ);
; 311  : 
; 312  : 	_asm sti
; 313  : 	_asm popad
; 314  : 	_asm iretd
; 315  : }
; 316  : 
; 317  : /**
; 318  : *	Controller Command Routines
; 319  : */
; 320  : 
; 321  : //! check interrupt status command
; 322  : void flpydsk_check_int(uint32_t* st0, uint32_t* cyl) {
; 323  : 
; 324  : 	flpydsk_send_command(FDC_CMD_CHECK_INT);
; 325  : 
; 326  : 	*st0 = flpydsk_read_data();
; 327  : 	*cyl = flpydsk_read_data();
; 328  : }
; 329  : 
; 330  : //! turns the current floppy drives motor on/off
; 331  : void flpydsk_control_motor(bool b) {
; 332  : 
; 333  : 	//! sanity check: invalid drive
; 334  : 	if (_CurrentDrive > 3)

	mov	al, BYTE PTR __CurrentDrive
	cmp	al, 3
	ja	SHORT $LN17@flpydsk_ca

; 335  : 		return;
; 336  : 
; 337  : 	uint8_t motor = 0;
; 338  : 
; 339  : 	//! select the correct mask based on current drive
; 340  : 	switch (_CurrentDrive) {

	movzx	edx, al
	xor	cl, cl
	cmp	edx, 3
	ja	SHORT $LN14@flpydsk_ca
	jmp	DWORD PTR $LN102@flpydsk_ca[edx*4]
$LN13@flpydsk_ca:

; 341  : 
; 342  : 	case 0:
; 343  : 		motor = FLPYDSK_DOR_MASK_DRIVE0_MOTOR;

	mov	cl, 16					; 00000010H

; 344  : 		break;

	jmp	SHORT $LN14@flpydsk_ca
$LN12@flpydsk_ca:

; 345  : 	case 1:
; 346  : 		motor = FLPYDSK_DOR_MASK_DRIVE1_MOTOR;

	mov	cl, 32					; 00000020H

; 347  : 		break;

	jmp	SHORT $LN14@flpydsk_ca
$LN11@flpydsk_ca:

; 348  : 	case 2:
; 349  : 		motor = FLPYDSK_DOR_MASK_DRIVE2_MOTOR;

	mov	cl, 64					; 00000040H

; 350  : 		break;

	jmp	SHORT $LN14@flpydsk_ca
$LN10@flpydsk_ca:

; 351  : 	case 3:
; 352  : 		motor = FLPYDSK_DOR_MASK_DRIVE3_MOTOR;

	mov	cl, 128					; 00000080H
$LN14@flpydsk_ca:

; 353  : 		break;
; 354  : 	}
; 355  : 
; 356  : 	//! turn on or off the motor of that drive
; 357  : 	if (b)
; 358  : 		flpydsk_write_dor(uint8_t(_CurrentDrive | motor | FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA));

	or	al, cl
	or	al, 12					; 0000000cH

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);

	movzx	eax, al
	push	eax
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb

; 359  : 	else
; 360  : 		flpydsk_write_dor(FLPYDSK_DOR_MASK_RESET);
; 361  : 
; 362  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 363  : 	sleep(20);

	push	20					; 00000014H
	call	?sleep@@YAXH@Z				; sleep
	add	esp, 12					; 0000000cH
$LN17@flpydsk_ca:
	push	edi

; 386  : 
; 387  : 	//! turn on the motor
; 388  : 	flpydsk_control_motor(true);
; 389  : 
; 390  : 	for (int i = 0; i < 10; i++) {

	xor	edi, edi
	push	esi
	npad	5
$LL4@flpydsk_ca:

; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL26@flpydsk_ca:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN77@flpydsk_ca

; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL26@flpydsk_ca

; 397  : 
; 398  : 		//! did we fine cylinder 0? if so, we are done
; 399  : 		if (!cyl) {

	jmp	SHORT $LN24@flpydsk_ca
$LN77@flpydsk_ca:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	7
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN24@flpydsk_ca:

; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
	npad	1
$LL34@flpydsk_ca:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN78@flpydsk_ca

; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL34@flpydsk_ca

; 397  : 
; 398  : 		//! did we fine cylinder 0? if so, we are done
; 399  : 		if (!cyl) {

	jmp	SHORT $LL40@flpydsk_ca
$LN78@flpydsk_ca:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	ebx
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
	npad	6
$LL40@flpydsk_ca:

; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)
; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)
; 273  : 			return inportb(FLPYDSK_FIFO);
; 274  : 
; 275  : 	return 0;
; 276  : }
; 277  : 
; 278  : //! write to the configuation control register
; 279  : void flpydsk_write_ccr(uint8_t val) {
; 280  : 
; 281  : 	//! write the configuation control
; 282  : 	outportb(FLPYDSK_CTRL, val);
; 283  : }
; 284  : 
; 285  : /**
; 286  : *	Interrupt Handling Routines
; 287  : */
; 288  : 
; 289  : //! wait for irq to fire
; 290  : inline void flpydsk_wait_irq() {
; 291  : 
; 292  : 	//! wait for irq to fire
; 293  : 	while (_FloppyDiskIRQ == 0)

	cmp	BYTE PTR __FloppyDiskIRQ, 0
	je	SHORT $LL40@flpydsk_ca

; 391  : 
; 392  : 		//! send command
; 393  : 		flpydsk_send_command(FDC_CMD_CALIBRATE);
; 394  : 		flpydsk_send_command(drive);
; 395  : 		flpydsk_wait_irq();
; 396  : 		flpydsk_check_int(&st0, &cyl);

	lea	eax, DWORD PTR _cyl$[esp+12]

; 294  : 		;
; 295  : 	_FloppyDiskIRQ = 0;

	mov	BYTE PTR __FloppyDiskIRQ, 0

; 391  : 
; 392  : 		//! send command
; 393  : 		flpydsk_send_command(FDC_CMD_CALIBRATE);
; 394  : 		flpydsk_send_command(drive);
; 395  : 		flpydsk_wait_irq();
; 396  : 		flpydsk_check_int(&st0, &cyl);

	push	eax
	lea	eax, DWORD PTR _st0$[esp+20]
	push	eax
	call	?flpydsk_check_int@@YAXPAI0@Z		; flpydsk_check_int
	add	esp, 8

; 397  : 
; 398  : 		//! did we fine cylinder 0? if so, we are done
; 399  : 		if (!cyl) {

	cmp	DWORD PTR _cyl$[esp+12], 0
	je	SHORT $LN79@flpydsk_ca

; 386  : 
; 387  : 	//! turn on the motor
; 388  : 	flpydsk_control_motor(true);
; 389  : 
; 390  : 	for (int i = 0; i < 10; i++) {

	inc	edi
	cmp	edi, 10					; 0000000aH
	jl	$LL4@flpydsk_ca

; 296  : }
; 297  : 
; 298  : 
; 299  : //!	floppy disk irq handler
; 300  : void _cdecl i86_flpy_irq() {
; 301  : 
; 302  : 	_asm add esp, 12
; 303  : 	_asm pushad
; 304  : 	_asm cli
; 305  : 
; 306  : 	//! irq fired
; 307  : 	_FloppyDiskIRQ = 1;
; 308  : 
; 309  : 	//! tell hal we are done
; 310  : 	intdone(FLOPPY_IRQ);
; 311  : 
; 312  : 	_asm sti
; 313  : 	_asm popad
; 314  : 	_asm iretd
; 315  : }
; 316  : 
; 317  : /**
; 318  : *	Controller Command Routines
; 319  : */
; 320  : 
; 321  : //! check interrupt status command
; 322  : void flpydsk_check_int(uint32_t* st0, uint32_t* cyl) {
; 323  : 
; 324  : 	flpydsk_send_command(FDC_CMD_CHECK_INT);
; 325  : 
; 326  : 	*st0 = flpydsk_read_data();
; 327  : 	*cyl = flpydsk_read_data();
; 328  : }
; 329  : 
; 330  : //! turns the current floppy drives motor on/off
; 331  : void flpydsk_control_motor(bool b) {
; 332  : 
; 333  : 	//! sanity check: invalid drive
; 334  : 	if (_CurrentDrive > 3)

	mov	al, BYTE PTR __CurrentDrive
	cmp	al, 3
	ja	SHORT $LN67@flpydsk_ca

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);

	push	4
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb

; 359  : 	else
; 360  : 		flpydsk_write_dor(FLPYDSK_DOR_MASK_RESET);
; 361  : 
; 362  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 363  : 	sleep(20);

	push	20					; 00000014H
	call	?sleep@@YAXH@Z				; sleep
	add	esp, 12					; 0000000cH
$LN67@flpydsk_ca:
	pop	esi
	pop	edi

; 403  : 		}
; 404  : 	}
; 405  : 
; 406  : 	flpydsk_control_motor(false);
; 407  : 	return -1;

	or	eax, -1
	pop	ebx

; 408  : }

	pop	ecx
	ret	0
$LN79@flpydsk_ca:

; 296  : }
; 297  : 
; 298  : 
; 299  : //!	floppy disk irq handler
; 300  : void _cdecl i86_flpy_irq() {
; 301  : 
; 302  : 	_asm add esp, 12
; 303  : 	_asm pushad
; 304  : 	_asm cli
; 305  : 
; 306  : 	//! irq fired
; 307  : 	_FloppyDiskIRQ = 1;
; 308  : 
; 309  : 	//! tell hal we are done
; 310  : 	intdone(FLOPPY_IRQ);
; 311  : 
; 312  : 	_asm sti
; 313  : 	_asm popad
; 314  : 	_asm iretd
; 315  : }
; 316  : 
; 317  : /**
; 318  : *	Controller Command Routines
; 319  : */
; 320  : 
; 321  : //! check interrupt status command
; 322  : void flpydsk_check_int(uint32_t* st0, uint32_t* cyl) {
; 323  : 
; 324  : 	flpydsk_send_command(FDC_CMD_CHECK_INT);
; 325  : 
; 326  : 	*st0 = flpydsk_read_data();
; 327  : 	*cyl = flpydsk_read_data();
; 328  : }
; 329  : 
; 330  : //! turns the current floppy drives motor on/off
; 331  : void flpydsk_control_motor(bool b) {
; 332  : 
; 333  : 	//! sanity check: invalid drive
; 334  : 	if (_CurrentDrive > 3)

	mov	al, BYTE PTR __CurrentDrive
	cmp	al, 3
	ja	SHORT $LN52@flpydsk_ca

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);

	push	4
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb

; 359  : 	else
; 360  : 		flpydsk_write_dor(FLPYDSK_DOR_MASK_RESET);
; 361  : 
; 362  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 363  : 	sleep(20);

	push	20					; 00000014H
	call	?sleep@@YAXH@Z				; sleep
	add	esp, 12					; 0000000cH
$LN52@flpydsk_ca:
	pop	esi
	pop	edi

; 400  : 
; 401  : 			flpydsk_control_motor(false);
; 402  : 			return 0;

	xor	eax, eax
	pop	ebx

; 408  : }

	pop	ecx
	ret	0
$LN102@flpydsk_ca:
	DD	$LN13@flpydsk_ca
	DD	$LN12@flpydsk_ca
	DD	$LN11@flpydsk_ca
	DD	$LN10@flpydsk_ca
?flpydsk_calibrate@@YAHE@Z ENDP				; flpydsk_calibrate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_stepr$ = 8						; size = 1
_data$ = 8						; size = 1
_loadt$ = 12						; size = 1
_unloadt$ = 16						; size = 1
_dma$ = 20						; size = 1
?flpydsk_drive_data@@YAXEEE_N@Z PROC			; flpydsk_drive_data

; 367  : void flpydsk_drive_data(uint8_t stepr, uint8_t loadt, uint8_t unloadt, bool dma) {

	push	esi

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL6@flpydsk_dr:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN30@flpydsk_dr

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL6@flpydsk_dr

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN4@flpydsk_dr
$LN30@flpydsk_dr:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	3
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN4@flpydsk_dr:

; 368  : 
; 369  : 	uint8_t data = 0;
; 370  : 
; 371  : 	//! send command
; 372  : 	flpydsk_send_command(FDC_CMD_SPECIFY);
; 373  : 	data = ((stepr & 0xf) << 4) | (unloadt & 0xf);

	mov	ecx, DWORD PTR _stepr$[esp]
	mov	eax, DWORD PTR _unloadt$[esp]
	shl	cl, 4
	and	al, 15					; 0000000fH
	or	cl, al

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi

; 368  : 
; 369  : 	uint8_t data = 0;
; 370  : 
; 371  : 	//! send command
; 372  : 	flpydsk_send_command(FDC_CMD_SPECIFY);
; 373  : 	data = ((stepr & 0xf) << 4) | (unloadt & 0xf);

	mov	BYTE PTR _data$[esp], cl
$LL14@flpydsk_dr:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN31@flpydsk_dr

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL14@flpydsk_dr

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN12@flpydsk_dr
$LN31@flpydsk_dr:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	DWORD PTR _data$[esp]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN12@flpydsk_dr:

; 374  : 	flpydsk_send_command(data);
; 375  : 	data = ((loadt << 1) | ((dma) ? 0 : 1));

	cmp	BYTE PTR _dma$[esp], 0
	mov	eax, DWORD PTR _loadt$[esp]
	sete	cl
	add	al, al
	or	cl, al

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi

; 374  : 	flpydsk_send_command(data);
; 375  : 	data = ((loadt << 1) | ((dma) ? 0 : 1));

	mov	BYTE PTR _data$[esp], cl
$LL22@flpydsk_dr:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN32@flpydsk_dr

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL22@flpydsk_dr
	pop	esi

; 376  : 	flpydsk_send_command(data);
; 377  : }

	ret	0
$LN32@flpydsk_dr:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	DWORD PTR _data$[esp]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
	pop	esi

; 376  : 	flpydsk_send_command(data);
; 377  : }

	ret	0
?flpydsk_drive_data@@YAXEEE_N@Z ENDP			; flpydsk_drive_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_b$ = 8							; size = 1
?flpydsk_control_motor@@YAX_N@Z PROC			; flpydsk_control_motor

; 332  : 
; 333  : 	//! sanity check: invalid drive
; 334  : 	if (_CurrentDrive > 3)

	mov	al, BYTE PTR __CurrentDrive
	cmp	al, 3
	ja	SHORT $LN10@flpydsk_co

; 335  : 		return;
; 336  : 
; 337  : 	uint8_t motor = 0;
; 338  : 
; 339  : 	//! select the correct mask based on current drive
; 340  : 	switch (_CurrentDrive) {

	movzx	edx, al
	xor	cl, cl
	cmp	edx, 3
	ja	SHORT $LN7@flpydsk_co
	jmp	DWORD PTR $LN19@flpydsk_co[edx*4]
$LN6@flpydsk_co:

; 341  : 
; 342  : 	case 0:
; 343  : 		motor = FLPYDSK_DOR_MASK_DRIVE0_MOTOR;

	mov	cl, 16					; 00000010H

; 344  : 		break;

	jmp	SHORT $LN7@flpydsk_co
$LN5@flpydsk_co:

; 345  : 	case 1:
; 346  : 		motor = FLPYDSK_DOR_MASK_DRIVE1_MOTOR;

	mov	cl, 32					; 00000020H

; 347  : 		break;

	jmp	SHORT $LN7@flpydsk_co
$LN4@flpydsk_co:

; 348  : 	case 2:
; 349  : 		motor = FLPYDSK_DOR_MASK_DRIVE2_MOTOR;

	mov	cl, 64					; 00000040H

; 350  : 		break;

	jmp	SHORT $LN7@flpydsk_co
$LN3@flpydsk_co:

; 351  : 	case 3:
; 352  : 		motor = FLPYDSK_DOR_MASK_DRIVE3_MOTOR;

	mov	cl, 128					; 00000080H
$LN7@flpydsk_co:

; 353  : 		break;
; 354  : 	}
; 355  : 
; 356  : 	//! turn on or off the motor of that drive
; 357  : 	if (b)

	cmp	BYTE PTR _b$[esp-4], 0
	je	SHORT $LN2@flpydsk_co

; 358  : 		flpydsk_write_dor(uint8_t(_CurrentDrive | motor | FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA));

	or	al, cl
	or	al, 12					; 0000000cH

; 255  : 	outportb(FLPYDSK_DOR, val);

	movzx	eax, al
	push	eax

; 359  : 	else

	jmp	SHORT $LN17@flpydsk_co
$LN2@flpydsk_co:

; 255  : 	outportb(FLPYDSK_DOR, val);

	push	4
$LN17@flpydsk_co:
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8

; 360  : 		flpydsk_write_dor(FLPYDSK_DOR_MASK_RESET);
; 361  : 
; 362  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 363  : 	sleep(20);

	mov	DWORD PTR _b$[esp-4], 20		; 00000014H
	jmp	?sleep@@YAXH@Z				; sleep
$LN10@flpydsk_co:

; 364  : }

	ret	0
	npad	2
$LN19@flpydsk_co:
	DD	$LN6@flpydsk_co
	DD	$LN5@flpydsk_co
	DD	$LN4@flpydsk_co
	DD	$LN3@flpydsk_co
?flpydsk_control_motor@@YAX_N@Z ENDP			; flpydsk_control_motor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_st0$ = 8						; size = 4
_cyl$ = 12						; size = 4
?flpydsk_check_int@@YAXPAI0@Z PROC			; flpydsk_check_int

; 322  : void flpydsk_check_int(uint32_t* st0, uint32_t* cyl) {

	push	esi

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL6@flpydsk_ch:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN30@flpydsk_ch

; 249  : }
; 250  : 
; 251  : //! write to the fdc dor
; 252  : void flpydsk_write_dor(uint8_t val) {
; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);
; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL6@flpydsk_ch

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	jmp	SHORT $LN4@flpydsk_ch
$LN30@flpydsk_ch:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	8
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
$LN4@flpydsk_ch:

; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL14@flpydsk_ch:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN31@flpydsk_ch

; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL14@flpydsk_ch

; 274  : 
; 275  : 	return 0;

	xor	al, al
	jmp	SHORT $LN15@flpydsk_ch
$LN31@flpydsk_ch:

; 273  : 			return inportb(FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
$LN15@flpydsk_ch:

; 323  : 
; 324  : 	flpydsk_send_command(FDC_CMD_CHECK_INT);
; 325  : 
; 326  : 	*st0 = flpydsk_read_data();

	movzx	ecx, al

; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi

; 323  : 
; 324  : 	flpydsk_send_command(FDC_CMD_CHECK_INT);
; 325  : 
; 326  : 	*st0 = flpydsk_read_data();

	mov	eax, DWORD PTR _st0$[esp]
	mov	DWORD PTR [eax], ecx
$LL22@flpydsk_ch:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN32@flpydsk_ch

; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL22@flpydsk_ch

; 274  : 
; 275  : 	return 0;

	xor	al, al

; 327  : 	*cyl = flpydsk_read_data();

	movzx	ecx, al
	mov	eax, DWORD PTR _cyl$[esp]
	pop	esi
	mov	DWORD PTR [eax], ecx

; 328  : }

	ret	0
$LN32@flpydsk_ch:

; 273  : 			return inportb(FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb

; 327  : 	*cyl = flpydsk_read_data();

	movzx	ecx, al

; 273  : 			return inportb(FLPYDSK_FIFO);

	add	esp, 4

; 327  : 	*cyl = flpydsk_read_data();

	mov	eax, DWORD PTR _cyl$[esp]
	pop	esi
	mov	DWORD PTR [eax], ecx

; 328  : }

	ret	0
?flpydsk_check_int@@YAXPAI0@Z ENDP			; flpydsk_check_int
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
?i86_flpy_irq@@YAXXZ PROC				; i86_flpy_irq

; 300  : void _cdecl i86_flpy_irq() {

	push	ebx
	push	esi
	push	edi

; 301  : 
; 302  : 	_asm add esp, 12

	add	esp, 12					; 0000000cH

; 303  : 	_asm pushad

	pushad

; 304  : 	_asm cli

	cli

; 305  : 
; 306  : 	//! irq fired
; 307  : 	_FloppyDiskIRQ = 1;

	mov	BYTE PTR __FloppyDiskIRQ, 1

; 308  : 
; 309  : 	//! tell hal we are done
; 310  : 	intdone(FLOPPY_IRQ);

	push	6
	call	?intdone@@YAXE@Z			; intdone
	add	esp, 4

; 311  : 
; 312  : 	_asm sti

	sti

; 313  : 	_asm popad

	popad

; 314  : 	_asm iretd

	iretd

; 315  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?i86_flpy_irq@@YAXXZ ENDP				; i86_flpy_irq
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
;	COMDAT ?flpydsk_wait_irq@@YAXXZ
_TEXT	SEGMENT
?flpydsk_wait_irq@@YAXXZ PROC				; flpydsk_wait_irq, COMDAT

; 290  : inline void flpydsk_wait_irq() {

$LL2@flpydsk_wa:

; 291  : 
; 292  : 	//! wait for irq to fire
; 293  : 	while (_FloppyDiskIRQ == 0)

	cmp	BYTE PTR __FloppyDiskIRQ, 0
	je	SHORT $LL2@flpydsk_wa

; 294  : 		;
; 295  : 	_FloppyDiskIRQ = 0;

	mov	BYTE PTR __FloppyDiskIRQ, 0

; 296  : }

	ret	0
?flpydsk_wait_irq@@YAXXZ ENDP				; flpydsk_wait_irq
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 1
?flpydsk_write_ccr@@YAXE@Z PROC				; flpydsk_write_ccr

; 280  : 
; 281  : 	//! write the configuation control
; 282  : 	outportb(FLPYDSK_CTRL, val);

	push	DWORD PTR _val$[esp-4]
	push	1015					; 000003f7H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8

; 283  : }

	ret	0
?flpydsk_write_ccr@@YAXE@Z ENDP				; flpydsk_write_ccr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
?flpydsk_read_data@@YAEXZ PROC				; flpydsk_read_data

; 268  : uint8_t flpydsk_read_data() {

	push	esi

; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL4@flpydsk_re:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN10@flpydsk_re

; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL4@flpydsk_re

; 274  : 
; 275  : 	return 0;

	xor	al, al
	pop	esi

; 276  : }

	ret	0
$LN10@flpydsk_re:

; 273  : 			return inportb(FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4
	pop	esi

; 276  : }

	ret	0
?flpydsk_read_data@@YAEXZ ENDP				; flpydsk_read_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_cmd$ = 8						; size = 1
?flpydsk_send_command@@YAXE@Z PROC			; flpydsk_send_command

; 259  : void flpydsk_send_command(uint8_t cmd) {

	push	esi

; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	xor	esi, esi
$LL4@flpydsk_se:

; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)

	test	al, al
	js	SHORT $LN10@flpydsk_se

; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)

	inc	esi
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL4@flpydsk_se
	pop	esi

; 265  : }

	ret	0
$LN10@flpydsk_se:

; 264  : 			return outportb(FLPYDSK_FIFO, cmd);

	push	DWORD PTR _cmd$[esp]
	push	1013					; 000003f5H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8
	pop	esi

; 265  : }

	ret	0
?flpydsk_send_command@@YAXE@Z ENDP			; flpydsk_send_command
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_val$ = 8						; size = 1
?flpydsk_write_dor@@YAXE@Z PROC				; flpydsk_write_dor

; 253  : 
; 254  : 	//! write the digital output register
; 255  : 	outportb(FLPYDSK_DOR, val);

	push	DWORD PTR _val$[esp-4]
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb
	add	esp, 8

; 256  : }

	ret	0
?flpydsk_write_dor@@YAXE@Z ENDP				; flpydsk_write_dor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
?flpydsk_read_status@@YAEXZ PROC			; flpydsk_read_status

; 246  : 
; 247  : 	//! just return main status register
; 248  : 	return inportb(FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?inportb@@YAEG@Z			; inportb
	add	esp, 4

; 249  : }

	ret	0
?flpydsk_read_status@@YAEXZ ENDP			; flpydsk_read_status
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_c$ = -8						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
?dma_initialize_floppy@@YA_NPAEI@Z PROC			; dma_initialize_floppy

; 198  : bool _cdecl dma_initialize_floppy(uint8_t* buffer, unsigned length){

	sub	esp, 8
	push	esi

; 199  : 	union{
; 200  : 		uint8_t byte[4];//Lo[0], Mid[1], Hi[2]
; 201  : 		unsigned long l;
; 202  : 	}a, c;
; 203  : 
; 204  : 	a.l = (unsigned)buffer;
; 205  : 	c.l = (unsigned)length - 1;

	mov	esi, DWORD PTR _length$[esp+8]
	push	edi

; 206  : 
; 207  : 	//Check for buffer issues
; 208  : 	if ((a.l >> 24) || (c.l >> 16) || (((a.l & 0xffff) + c.l) >> 16)){

	mov	edi, DWORD PTR _buffer$[esp+12]
	dec	esi
	mov	DWORD PTR _c$[esp+16], esi
	test	edi, -16777216				; ff000000H
	jne	SHORT $LN1@dma_initia
	test	esi, -65536				; ffff0000H
	jne	SHORT $LN1@dma_initia
	movzx	eax, di
	add	eax, esi
	test	eax, -65536				; ffff0000H
	jne	SHORT $LN1@dma_initia

; 217  : 	}
; 218  : 
; 219  : 	dma_reset(1);

	push	1
	call	?dma_reset@@YAXH@Z			; dma_reset

; 220  : 	dma_mask_channel(FDC_DMA_CHANNEL);//Mask channel 2

	push	2
	call	?dma_mask_channel@@YAXE@Z		; dma_mask_channel

; 221  : 	dma_reset_flipflop(1);//Flipflop reset on DMA 1

	push	1
	call	?dma_reset_flipflop@@YAXH@Z		; dma_reset_flipflop

; 222  : 
; 223  : 	dma_set_address(FDC_DMA_CHANNEL, a.byte[0], a.byte[1]);//Buffer address

	push	DWORD PTR _buffer$[esp+25]
	push	edi
	push	2
	call	?dma_set_address@@YAXEEE@Z		; dma_set_address

; 224  : 	dma_reset_flipflop(1);//Flipflop reset on DMA 1

	push	1
	call	?dma_reset_flipflop@@YAXH@Z		; dma_reset_flipflop

; 225  : 
; 226  : 	dma_set_count(FDC_DMA_CHANNEL, c.byte[0], c.byte[1]);//Set count

	push	DWORD PTR _c$[esp+45]
	push	esi
	push	2
	call	?dma_set_count@@YAXEEE@Z		; dma_set_count

; 227  : 	dma_set_read(FDC_DMA_CHANNEL);

	push	2
	call	?dma_set_read@@YAXE@Z			; dma_set_read

; 228  : 
; 229  : 	dma_unmask_all(1);//Unmask channel 2

	push	1
	call	?dma_unmask_all@@YAXH@Z			; dma_unmask_all
	add	esp, 48					; 00000030H

; 230  : 
; 231  : 	return true;

	mov	al, 1
	pop	edi
	pop	esi

; 232  : }

	add	esp, 8
	ret	0
$LN1@dma_initia:
	pop	edi

; 209  : #ifdef _DEBUG
; 210  : 		_asm{
; 211  : 			mov      eax, 0x1337
; 212  : 				cli
; 213  : 				hlt
; 214  : 		}
; 215  : #endif
; 216  : 		return false;

	xor	al, al
	pop	esi

; 232  : }

	add	esp, 8
	ret	0
?dma_initialize_floppy@@YA_NPAEI@Z ENDP			; dma_initialize_floppy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_lba$ = 8						; size = 4
_head$ = 12						; size = 4
_track$ = 16						; size = 4
_sector$ = 20						; size = 4
?flpydsk_lba_to_chs@@YAXHPAH00@Z PROC			; flpydsk_lba_to_chs

; 512  : void flpydsk_lba_to_chs(int lba, int *head, int *track, int *sector) {

	push	ebx

; 513  : 
; 514  : 	*head = (lba % (FLPY_SECTORS_PER_TRACK * 2)) / (FLPY_SECTORS_PER_TRACK);

	mov	ebx, DWORD PTR _lba$[esp]
	mov	eax, 954437177				; 38e38e39H
	imul	ebx
	push	esi
	sar	edx, 3
	mov	ecx, ebx
	push	edi
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	lea	eax, DWORD PTR [edi+edi*8]
	shl	eax, 2
	sub	ecx, eax
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	mov	ecx, DWORD PTR _head$[esp+8]

; 515  : 	*track = lba / (FLPY_SECTORS_PER_TRACK * 2);
; 516  : 	*sector = lba % FLPY_SECTORS_PER_TRACK + 1;

	mov	eax, 954437177				; 38e38e39H
	sar	edx, 2
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	imul	ebx
	mov	DWORD PTR [ecx], esi
	mov	ecx, DWORD PTR _track$[esp+8]
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [ecx], edi
	pop	edi
	pop	esi
	lea	eax, DWORD PTR [eax+eax*8]
	add	eax, eax
	sub	ebx, eax
	mov	eax, DWORD PTR _sector$[esp]
	inc	ebx
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 517  : }

	ret	0
?flpydsk_lba_to_chs@@YAXHPAH00@Z ENDP			; flpydsk_lba_to_chs
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
tv170 = -4						; size = 4
_sectorLBA$ = 8						; size = 4
?flpydsk_read_sector@@YAPAEH@Z PROC			; flpydsk_read_sector

; 546  : uint8_t* flpydsk_read_sector(int sectorLBA) {

	push	ecx
	push	ebx

; 547  : 
; 548  : 	if (_CurrentDrive >= 4)

	mov	bl, BYTE PTR __CurrentDrive
	cmp	bl, 4
	jb	SHORT $LN2@flpydsk_re

; 549  : 		return 0;

	xor	eax, eax
	pop	ebx

; 566  : }

	pop	ecx
	ret	0
$LN2@flpydsk_re:
	push	ebp

; 364  : }
; 365  : 
; 366  : //! configure drive
; 367  : void flpydsk_drive_data(uint8_t stepr, uint8_t loadt, uint8_t unloadt, bool dma) {
; 368  : 
; 369  : 	uint8_t data = 0;
; 370  : 
; 371  : 	//! send command
; 372  : 	flpydsk_send_command(FDC_CMD_SPECIFY);
; 373  : 	data = ((stepr & 0xf) << 4) | (unloadt & 0xf);
; 374  : 	flpydsk_send_command(data);
; 375  : 	data = ((loadt << 1) | ((dma) ? 0 : 1));
; 376  : 	flpydsk_send_command(data);
; 377  : }
; 378  : 
; 379  : //! calibrates the drive
; 380  : int flpydsk_calibrate(uint8_t drive) {
; 381  : 
; 382  : 	uint32_t st0, cyl;
; 383  : 
; 384  : 	if (drive >= 4)
; 385  : 		return -2;
; 386  : 
; 387  : 	//! turn on the motor
; 388  : 	flpydsk_control_motor(true);
; 389  : 
; 390  : 	for (int i = 0; i < 10; i++) {
; 391  : 
; 392  : 		//! send command
; 393  : 		flpydsk_send_command(FDC_CMD_CALIBRATE);
; 394  : 		flpydsk_send_command(drive);
; 395  : 		flpydsk_wait_irq();
; 396  : 		flpydsk_check_int(&st0, &cyl);
; 397  : 
; 398  : 		//! did we fine cylinder 0? if so, we are done
; 399  : 		if (!cyl) {
; 400  : 
; 401  : 			flpydsk_control_motor(false);
; 402  : 			return 0;
; 403  : 		}
; 404  : 	}
; 405  : 
; 406  : 	flpydsk_control_motor(false);
; 407  : 	return -1;
; 408  : }
; 409  : 
; 410  : //! disable controller
; 411  : void flpydsk_disable_controller() {
; 412  : 
; 413  : 	flpydsk_write_dor(0);
; 414  : }
; 415  : 
; 416  : //! enable controller
; 417  : void flpydsk_enable_controller() {
; 418  : 
; 419  : 	flpydsk_write_dor(FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA);
; 420  : }
; 421  : 
; 422  : //! reset controller
; 423  : void flpydsk_reset() {
; 424  : 
; 425  : 	uint32_t st0, cyl;
; 426  : 
; 427  : 	//! reset the controller
; 428  : 	flpydsk_disable_controller();
; 429  : 	flpydsk_enable_controller();
; 430  : 	flpydsk_wait_irq();
; 431  : 
; 432  : 	//! send CHECK_INT/SENSE INTERRUPT command to all drives
; 433  : 	for (int i = 0; i<4; i++)
; 434  : 		flpydsk_check_int(&st0, &cyl);
; 435  : 
; 436  : 	//! transfer speed 500kb/s
; 437  : 	flpydsk_write_ccr(0);
; 438  : 
; 439  : 	//! pass mechanical drive info. steprate=3ms, unload time=240ms, load time=16ms
; 440  : 	flpydsk_drive_data(3, 16, 240, true);
; 441  : 
; 442  : 	//! calibrate the disk
; 443  : 	flpydsk_calibrate(_CurrentDrive);
; 444  : }
; 445  : 
; 446  : //! read a sector
; 447  : void flpydsk_read_sector_imp(uint8_t head, uint8_t track, uint8_t sector) {
; 448  : 
; 449  : 	uint32_t st0, cyl;
; 450  : 
; 451  : 	//! initialize DMA
; 452  : 	dma_initialize_floppy((uint8_t*)DMA_BUFFER, 512);
; 453  : 
; 454  : 	//! set the DMA for read transfer
; 455  : 	dma_set_read(FDC_DMA_CHANNEL);
; 456  : 
; 457  : 	//! read in a sector
; 458  : 	flpydsk_send_command(
; 459  : 		FDC_CMD_READ_SECT | FDC_CMD_EXT_MULTITRACK | FDC_CMD_EXT_SKIP | FDC_CMD_EXT_DENSITY);
; 460  : 	flpydsk_send_command(head << 2 | _CurrentDrive);
; 461  : 	flpydsk_send_command(track);
; 462  : 	flpydsk_send_command(head);
; 463  : 	flpydsk_send_command(sector);
; 464  : 	flpydsk_send_command(FLPYDSK_SECTOR_DTL_512);
; 465  : 	flpydsk_send_command(((sector + 1) >= FLPY_SECTORS_PER_TRACK) ? FLPY_SECTORS_PER_TRACK : sector + 1);
; 466  : 	flpydsk_send_command(FLPYDSK_GAP3_LENGTH_3_5);
; 467  : 	flpydsk_send_command(0xff);
; 468  : 
; 469  : 	//! wait for irq
; 470  : 	flpydsk_wait_irq();
; 471  : 
; 472  : 	//! read status info
; 473  : 	for (int j = 0; j<7; j++)
; 474  : 		flpydsk_read_data();
; 475  : 
; 476  : 	//! let FDC know we handled interrupt
; 477  : 	flpydsk_check_int(&st0, &cyl);
; 478  : }
; 479  : 
; 480  : //! seek to given track/cylinder
; 481  : int flpydsk_seek(uint8_t cyl, uint8_t head) {
; 482  : 
; 483  : 	uint32_t st0, cyl0;
; 484  : 
; 485  : 	if (_CurrentDrive >= 4)
; 486  : 		return -1;
; 487  : 
; 488  : 	for (int i = 0; i < 10; i++) {
; 489  : 
; 490  : 		//! send the command
; 491  : 		flpydsk_send_command(FDC_CMD_SEEK);
; 492  : 		flpydsk_send_command((head) << 2 | _CurrentDrive);
; 493  : 		flpydsk_send_command(cyl);
; 494  : 
; 495  : 		//! wait for the results phase IRQ
; 496  : 		flpydsk_wait_irq();
; 497  : 		flpydsk_check_int(&st0, &cyl0);
; 498  : 
; 499  : 		//! found the cylinder?
; 500  : 		if (cyl0 == cyl)
; 501  : 			return 0;
; 502  : 	}
; 503  : 
; 504  : 	return -1;
; 505  : }
; 506  : 
; 507  : //============================================================================
; 508  : //    INTERFACE FUNCTIONS
; 509  : //============================================================================
; 510  : 
; 511  : //! convert LBA to CHS
; 512  : void flpydsk_lba_to_chs(int lba, int *head, int *track, int *sector) {
; 513  : 
; 514  : 	*head = (lba % (FLPY_SECTORS_PER_TRACK * 2)) / (FLPY_SECTORS_PER_TRACK);

	mov	ebp, DWORD PTR _sectorLBA$[esp+8]
	mov	eax, 954437177				; 38e38e39H
	imul	ebp
	push	esi
	sar	edx, 3
	mov	ecx, ebp
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	push	edi
	lea	eax, DWORD PTR [esi+esi*8]
	shl	eax, 2
	sub	ecx, eax
	mov	eax, 954437177				; 38e38e39H
	imul	ecx

; 515  : 	*track = lba / (FLPY_SECTORS_PER_TRACK * 2);
; 516  : 	*sector = lba % FLPY_SECTORS_PER_TRACK + 1;

	mov	eax, 954437177				; 38e38e39H
	sar	edx, 2
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	imul	ebp
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	eax, DWORD PTR [eax+eax*8]
	add	eax, eax
	sub	ebp, eax
	inc	ebp

; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)
; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)
; 264  : 			return outportb(FLPYDSK_FIFO, cmd);
; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)
; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)
; 273  : 			return inportb(FLPYDSK_FIFO);
; 274  : 
; 275  : 	return 0;
; 276  : }
; 277  : 
; 278  : //! write to the configuation control register
; 279  : void flpydsk_write_ccr(uint8_t val) {
; 280  : 
; 281  : 	//! write the configuation control
; 282  : 	outportb(FLPYDSK_CTRL, val);
; 283  : }
; 284  : 
; 285  : /**
; 286  : *	Interrupt Handling Routines
; 287  : */
; 288  : 
; 289  : //! wait for irq to fire
; 290  : inline void flpydsk_wait_irq() {
; 291  : 
; 292  : 	//! wait for irq to fire
; 293  : 	while (_FloppyDiskIRQ == 0)
; 294  : 		;
; 295  : 	_FloppyDiskIRQ = 0;
; 296  : }
; 297  : 
; 298  : 
; 299  : //!	floppy disk irq handler
; 300  : void _cdecl i86_flpy_irq() {
; 301  : 
; 302  : 	_asm add esp, 12
; 303  : 	_asm pushad
; 304  : 	_asm cli
; 305  : 
; 306  : 	//! irq fired
; 307  : 	_FloppyDiskIRQ = 1;
; 308  : 
; 309  : 	//! tell hal we are done
; 310  : 	intdone(FLOPPY_IRQ);
; 311  : 
; 312  : 	_asm sti
; 313  : 	_asm popad
; 314  : 	_asm iretd
; 315  : }
; 316  : 
; 317  : /**
; 318  : *	Controller Command Routines
; 319  : */
; 320  : 
; 321  : //! check interrupt status command
; 322  : void flpydsk_check_int(uint32_t* st0, uint32_t* cyl) {
; 323  : 
; 324  : 	flpydsk_send_command(FDC_CMD_CHECK_INT);
; 325  : 
; 326  : 	*st0 = flpydsk_read_data();
; 327  : 	*cyl = flpydsk_read_data();
; 328  : }
; 329  : 
; 330  : //! turns the current floppy drives motor on/off
; 331  : void flpydsk_control_motor(bool b) {
; 332  : 
; 333  : 	//! sanity check: invalid drive
; 334  : 	if (_CurrentDrive > 3)

	cmp	bl, 3
	ja	SHORT $LN16@flpydsk_re

; 335  : 		return;
; 336  : 
; 337  : 	uint8_t motor = 0;
; 338  : 
; 339  : 	//! select the correct mask based on current drive
; 340  : 	switch (_CurrentDrive) {

	movzx	ecx, bl
	xor	al, al
	cmp	ecx, 3
	ja	SHORT $LN13@flpydsk_re
	jmp	DWORD PTR $LN41@flpydsk_re[ecx*4]
$LN12@flpydsk_re:

; 341  : 
; 342  : 	case 0:
; 343  : 		motor = FLPYDSK_DOR_MASK_DRIVE0_MOTOR;

	mov	al, 16					; 00000010H

; 344  : 		break;

	jmp	SHORT $LN13@flpydsk_re
$LN11@flpydsk_re:

; 345  : 	case 1:
; 346  : 		motor = FLPYDSK_DOR_MASK_DRIVE1_MOTOR;

	mov	al, 32					; 00000020H

; 347  : 		break;

	jmp	SHORT $LN13@flpydsk_re
$LN10@flpydsk_re:

; 348  : 	case 2:
; 349  : 		motor = FLPYDSK_DOR_MASK_DRIVE2_MOTOR;

	mov	al, 64					; 00000040H

; 350  : 		break;

	jmp	SHORT $LN13@flpydsk_re
$LN9@flpydsk_re:

; 351  : 	case 3:
; 352  : 		motor = FLPYDSK_DOR_MASK_DRIVE3_MOTOR;

	mov	al, 128					; 00000080H
$LN13@flpydsk_re:

; 353  : 		break;
; 354  : 	}
; 355  : 
; 356  : 	//! turn on or off the motor of that drive
; 357  : 	if (b)
; 358  : 		flpydsk_write_dor(uint8_t(_CurrentDrive | motor | FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA));

	or	bl, al
	or	bl, 12					; 0000000cH

; 255  : 	outportb(FLPYDSK_DOR, val);

	movzx	eax, bl
	push	eax
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb

; 359  : 	else
; 360  : 		flpydsk_write_dor(FLPYDSK_DOR_MASK_RESET);
; 361  : 
; 362  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 363  : 	sleep(20);

	push	20					; 00000014H
	call	?sleep@@YAXH@Z				; sleep
	add	esp, 12					; 0000000cH
$LN16@flpydsk_re:

; 550  : 
; 551  : 	//! convert LBA sector to CHS
; 552  : 	int head = 0, track = 0, sector = 1;
; 553  : 	flpydsk_lba_to_chs(sectorLBA, &head, &track, &sector);
; 554  : 
; 555  : 	//! turn motor on and seek to track
; 556  : 	flpydsk_control_motor(true);
; 557  : 	if (flpydsk_seek((uint8_t)track, (uint8_t)head) != 0)

	push	edi
	push	esi
	call	?flpydsk_seek@@YAHEE@Z			; flpydsk_seek
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@flpydsk_re

; 558  : 		return 0;

	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 566  : }

	pop	ecx
	ret	0
$LN1@flpydsk_re:

; 559  : 
; 560  : 	//! read sector and turn motor off
; 561  : 	flpydsk_read_sector_imp((uint8_t)head, (uint8_t)track, (uint8_t)sector);

	push	ebp
	push	esi
	push	edi
	call	?flpydsk_read_sector_imp@@YAXEEE@Z	; flpydsk_read_sector_imp

; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)
; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)
; 264  : 			return outportb(FLPYDSK_FIFO, cmd);
; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)
; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)
; 273  : 			return inportb(FLPYDSK_FIFO);
; 274  : 
; 275  : 	return 0;
; 276  : }
; 277  : 
; 278  : //! write to the configuation control register
; 279  : void flpydsk_write_ccr(uint8_t val) {
; 280  : 
; 281  : 	//! write the configuation control
; 282  : 	outportb(FLPYDSK_CTRL, val);
; 283  : }
; 284  : 
; 285  : /**
; 286  : *	Interrupt Handling Routines
; 287  : */
; 288  : 
; 289  : //! wait for irq to fire
; 290  : inline void flpydsk_wait_irq() {
; 291  : 
; 292  : 	//! wait for irq to fire
; 293  : 	while (_FloppyDiskIRQ == 0)
; 294  : 		;
; 295  : 	_FloppyDiskIRQ = 0;
; 296  : }
; 297  : 
; 298  : 
; 299  : //!	floppy disk irq handler
; 300  : void _cdecl i86_flpy_irq() {
; 301  : 
; 302  : 	_asm add esp, 12
; 303  : 	_asm pushad
; 304  : 	_asm cli
; 305  : 
; 306  : 	//! irq fired
; 307  : 	_FloppyDiskIRQ = 1;
; 308  : 
; 309  : 	//! tell hal we are done
; 310  : 	intdone(FLOPPY_IRQ);
; 311  : 
; 312  : 	_asm sti
; 313  : 	_asm popad
; 314  : 	_asm iretd
; 315  : }
; 316  : 
; 317  : /**
; 318  : *	Controller Command Routines
; 319  : */
; 320  : 
; 321  : //! check interrupt status command
; 322  : void flpydsk_check_int(uint32_t* st0, uint32_t* cyl) {
; 323  : 
; 324  : 	flpydsk_send_command(FDC_CMD_CHECK_INT);
; 325  : 
; 326  : 	*st0 = flpydsk_read_data();
; 327  : 	*cyl = flpydsk_read_data();
; 328  : }
; 329  : 
; 330  : //! turns the current floppy drives motor on/off
; 331  : void flpydsk_control_motor(bool b) {
; 332  : 
; 333  : 	//! sanity check: invalid drive
; 334  : 	if (_CurrentDrive > 3)

	mov	al, BYTE PTR __CurrentDrive

; 559  : 
; 560  : 	//! read sector and turn motor off
; 561  : 	flpydsk_read_sector_imp((uint8_t)head, (uint8_t)track, (uint8_t)sector);

	add	esp, 12					; 0000000cH

; 256  : }
; 257  : 
; 258  : //! send command byte to fdc
; 259  : void flpydsk_send_command(uint8_t cmd) {
; 260  : 
; 261  : 	//! wait until data register is ready. We send commands to the data register
; 262  : 	for (int i = 0; i < 500; i++)
; 263  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)
; 264  : 			return outportb(FLPYDSK_FIFO, cmd);
; 265  : }
; 266  : 
; 267  : //! get data from fdc
; 268  : uint8_t flpydsk_read_data() {
; 269  : 
; 270  : 	//! same as above function but returns data register for reading
; 271  : 	for (int i = 0; i < 500; i++)
; 272  : 		if (flpydsk_read_status() & FLPYDSK_MSR_MASK_DATAREG)
; 273  : 			return inportb(FLPYDSK_FIFO);
; 274  : 
; 275  : 	return 0;
; 276  : }
; 277  : 
; 278  : //! write to the configuation control register
; 279  : void flpydsk_write_ccr(uint8_t val) {
; 280  : 
; 281  : 	//! write the configuation control
; 282  : 	outportb(FLPYDSK_CTRL, val);
; 283  : }
; 284  : 
; 285  : /**
; 286  : *	Interrupt Handling Routines
; 287  : */
; 288  : 
; 289  : //! wait for irq to fire
; 290  : inline void flpydsk_wait_irq() {
; 291  : 
; 292  : 	//! wait for irq to fire
; 293  : 	while (_FloppyDiskIRQ == 0)
; 294  : 		;
; 295  : 	_FloppyDiskIRQ = 0;
; 296  : }
; 297  : 
; 298  : 
; 299  : //!	floppy disk irq handler
; 300  : void _cdecl i86_flpy_irq() {
; 301  : 
; 302  : 	_asm add esp, 12
; 303  : 	_asm pushad
; 304  : 	_asm cli
; 305  : 
; 306  : 	//! irq fired
; 307  : 	_FloppyDiskIRQ = 1;
; 308  : 
; 309  : 	//! tell hal we are done
; 310  : 	intdone(FLOPPY_IRQ);
; 311  : 
; 312  : 	_asm sti
; 313  : 	_asm popad
; 314  : 	_asm iretd
; 315  : }
; 316  : 
; 317  : /**
; 318  : *	Controller Command Routines
; 319  : */
; 320  : 
; 321  : //! check interrupt status command
; 322  : void flpydsk_check_int(uint32_t* st0, uint32_t* cyl) {
; 323  : 
; 324  : 	flpydsk_send_command(FDC_CMD_CHECK_INT);
; 325  : 
; 326  : 	*st0 = flpydsk_read_data();
; 327  : 	*cyl = flpydsk_read_data();
; 328  : }
; 329  : 
; 330  : //! turns the current floppy drives motor on/off
; 331  : void flpydsk_control_motor(bool b) {
; 332  : 
; 333  : 	//! sanity check: invalid drive
; 334  : 	if (_CurrentDrive > 3)

	cmp	al, 3
	ja	SHORT $LN31@flpydsk_re

; 255  : 	outportb(FLPYDSK_DOR, val);

	push	4
	push	1010					; 000003f2H
	call	?outportb@@YAXGE@Z			; outportb

; 359  : 	else
; 360  : 		flpydsk_write_dor(FLPYDSK_DOR_MASK_RESET);
; 361  : 
; 362  : 	//! in all cases; wait a little bit for the motor to spin up/turn off
; 363  : 	sleep(20);

	push	20					; 00000014H
	call	?sleep@@YAXH@Z				; sleep
	add	esp, 12					; 0000000cH
$LN31@flpydsk_re:

; 562  : 	flpydsk_control_motor(false);
; 563  : 
; 564  : 	//! warning: this is a bit hackish
; 565  : 	return (uint8_t*)DMA_BUFFER;

	mov	eax, DWORD PTR ?DMA_BUFFER@@3HA		; DMA_BUFFER
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 566  : }

	pop	ecx
	ret	0
	npad	2
$LN41@flpydsk_re:
	DD	$LN12@flpydsk_re
	DD	$LN11@flpydsk_re
	DD	$LN10@flpydsk_re
	DD	$LN9@flpydsk_re
?flpydsk_read_sector@@YAPAEH@Z ENDP			; flpydsk_read_sector
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
?flpydsk_get_working_drive@@YAEXZ PROC			; flpydsk_get_working_drive

; 541  : 
; 542  : 	return _CurrentDrive;

	mov	al, BYTE PTR __CurrentDrive

; 543  : }

	ret	0
?flpydsk_get_working_drive@@YAEXZ ENDP			; flpydsk_get_working_drive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_drive$ = 8						; size = 1
?flpydsk_set_working_drive@@YAXE@Z PROC			; flpydsk_set_working_drive

; 534  : 
; 535  : 	if (drive < 4)

	movzx	edx, BYTE PTR __CurrentDrive
	cmp	BYTE PTR _drive$[esp-4], 4
	movzx	ecx, BYTE PTR _drive$[esp-4]
	cmovb	edx, ecx
	mov	BYTE PTR __CurrentDrive, dl

; 536  : 		_CurrentDrive = drive;
; 537  : }

	ret	0
?flpydsk_set_working_drive@@YAXE@Z ENDP			; flpydsk_set_working_drive
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_irq$ = 8						; size = 4
?flpydsk_install@@YAXH@Z PROC				; flpydsk_install

; 521  : 
; 522  : 	//! install irq handler
; 523  : 	setvect(irq, i86_flpy_irq);

	push	OFFSET ?i86_flpy_irq@@YAXXZ		; i86_flpy_irq
	push	DWORD PTR _irq$[esp]
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 524  : 
; 525  : 	//! reset the fdc
; 526  : 	flpydsk_reset();

	call	?flpydsk_reset@@YAXXZ			; flpydsk_reset

; 527  : 
; 528  : 	//! set drive information
; 529  : 	flpydsk_drive_data(13, 1, 0xf, true);

	push	1
	push	15					; 0000000fH
	push	1
	push	13					; 0000000dH
	call	?flpydsk_drive_data@@YAXEEE_N@Z		; flpydsk_drive_data
	add	esp, 24					; 00000018H

; 530  : }

	ret	0
?flpydsk_install@@YAXH@Z ENDP				; flpydsk_install
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\flopydisk\flopy.cpp
_TEXT	SEGMENT
_addr$ = 8						; size = 4
?flpydsk_set_dma@@YAXH@Z PROC				; flpydsk_set_dma

; 236  : 
; 237  : 	DMA_BUFFER = addr;

	mov	eax, DWORD PTR _addr$[esp-4]
	mov	DWORD PTR ?DMA_BUFFER@@3HA, eax		; DMA_BUFFER

; 238  : }

	ret	0
?flpydsk_set_dma@@YAXH@Z ENDP				; flpydsk_set_dma
_TEXT	ENDS
END
