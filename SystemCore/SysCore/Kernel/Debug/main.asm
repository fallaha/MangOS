; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Ali\Desktop\MangOS\SystemCore\SysCore\Kernel\main.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG2828	DB	'    Mango  Operating System is Loading ....             '
	DB	'                        ', 00H
	ORG $+3
$SG2829	DB	'we are optimizing th operating system WindowsX!', 0aH, 00H
	ORG $+3
$SG2831	DB	'ram Amount : %d', 00H
$SG2832	DB	'CTRL+ALT+DEL to restart                                 '
	DB	'                        ', 00H
	ORG $+3
$SG2840	DB	'Base Frame : %d  and limit Block %d type: %d ', 0aH, 00H
	ORG $+1
$SG2842	DB	'Kernel Block : %d ', 0aH, 00H
$SG2843	DB	0aH, 'pmm regions initialized: %i allocation blocks; used'
	DB	' or reserved blocks: %i', 0aH, 'free blocks: %i', 0aH, 00H
	ORG $+3
$SG2846	DB	0aH, 'p allocated at frame : %d', 00H
	ORG $+1
$SG2849	DB	0aH, 'allocated 2 blocks for p2 at frame : %d', 00H
	ORG $+3
$SG2852	DB	0aH, 'p allocated at frame : %d', 00H
	ORG $+1
$SG2854	DB	0aH, 'Unallocated p to free block 1. p is reallocated to '
	DB	'frame : %d', 00H
	ORG $+1
$SG2858	DB	'Count = %d', 00H
CONST	ENDS
PUBLIC	_main
EXTRN	?DebugGotoXY@@YAXEE@Z:PROC			; DebugGotoXY
EXTRN	?DebugClrScreen@@YAXE@Z:PROC			; DebugClrScreen
EXTRN	?DebugSetColor@@YAXG@Z:PROC			; DebugSetColor
EXTRN	?DebugPuts@@YAXPAD@Z:PROC			; DebugPuts
EXTRN	?DebugPrintf@@YAHPBDZZ:PROC			; DebugPrintf
EXTRN	?hal_initialize@@YAXXZ:PROC			; hal_initialize
EXTRN	?setvect@@YAXIA6AXXZ@Z:PROC			; setvect
EXTRN	?interrupt_enable@@YAXXZ:PROC			; interrupt_enable
EXTRN	?get_tick@@YAIXZ:PROC				; get_tick
EXTRN	?divide_by_zero_fault@@YAXIII@Z:PROC		; divide_by_zero_fault
EXTRN	?single_step_trap@@YAXIII@Z:PROC		; single_step_trap
EXTRN	?nmi_trap@@YAXIII@Z:PROC			; nmi_trap
EXTRN	?breakpoint_trap@@YAXIII@Z:PROC			; breakpoint_trap
EXTRN	?overflow_trap@@YAXIII@Z:PROC			; overflow_trap
EXTRN	?bounds_check_fault@@YAXIII@Z:PROC		; bounds_check_fault
EXTRN	?invalid_opcode_fault@@YAXIII@Z:PROC		; invalid_opcode_fault
EXTRN	?no_device_fault@@YAXIII@Z:PROC			; no_device_fault
EXTRN	?double_fault_abort@@YAXIIII@Z:PROC		; double_fault_abort
EXTRN	?invalid_tss_fault@@YAXIIII@Z:PROC		; invalid_tss_fault
EXTRN	?no_segment_fault@@YAXIIII@Z:PROC		; no_segment_fault
EXTRN	?stack_fault@@YAXIIII@Z:PROC			; stack_fault
EXTRN	?general_protection_fault@@YAXIIII@Z:PROC	; general_protection_fault
EXTRN	?page_fault@@YAXIIII@Z:PROC			; page_fault
EXTRN	?fpu_fault@@YAXIII@Z:PROC			; fpu_fault
EXTRN	?alignment_check_fault@@YAXIIII@Z:PROC		; alignment_check_fault
EXTRN	?machine_check_abort@@YAXIII@Z:PROC		; machine_check_abort
EXTRN	?simd_fpu_fault@@YAXIII@Z:PROC			; simd_fpu_fault
EXTRN	?pmm_initialize@@YAXII@Z:PROC			; pmm_initialize
EXTRN	?pmm_set_region@@YAXII@Z:PROC			; pmm_set_region
EXTRN	?pmm_clr_region@@YAXII@Z:PROC			; pmm_clr_region
EXTRN	?pmm_alloc_block@@YAPAXXZ:PROC			; pmm_alloc_block
EXTRN	?pmm_free_block@@YAXPAI@Z:PROC			; pmm_free_block
EXTRN	?pmm_alloc_block_s@@YAPAXI@Z:PROC		; pmm_alloc_block_s
EXTRN	?pmm_free_block_s@@YAXPAII@Z:PROC		; pmm_free_block_s
EXTRN	?pmm_get_max_blocks@@YAIXZ:PROC			; pmm_get_max_blocks
EXTRN	?pmm_get_free_block_count@@YAIXZ:PROC		; pmm_get_free_block_count
EXTRN	?pmm_get_used_block_count@@YAIXZ:PROC		; pmm_get_used_block_count
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\main.cpp
_TEXT	SEGMENT
_kernel_img_size$ = -4					; size = 4
_info$ = 8						; size = 4
_main	PROC

; 17   : int _cdecl main(multiboot_info* info) {

	push	ecx
	push	esi
	push	edi

; 18   : 	uint32_t kernel_img_size;
; 19   : 	_asm mov word ptr[kernel_img_size], dx /*Get Kernel Image Size form Bootloader*/

	mov	WORD PTR _kernel_img_size$[esp+12], dx

; 20   : 	hal_initialize();

	call	?hal_initialize@@YAXXZ			; hal_initialize

; 21   : 
; 22   : 	//! install our exception handlers
; 23   : 	setvect(0, (void(__cdecl &)(void))divide_by_zero_fault);

	push	OFFSET ?divide_by_zero_fault@@YAXIII@Z	; divide_by_zero_fault
	push	0
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 24   : 	setvect(1, (void(__cdecl &)(void))single_step_trap);

	push	OFFSET ?single_step_trap@@YAXIII@Z	; single_step_trap
	push	1
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 25   : 	setvect(2, (void(__cdecl &)(void))nmi_trap);

	push	OFFSET ?nmi_trap@@YAXIII@Z		; nmi_trap
	push	2
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 26   : 	setvect(3, (void(__cdecl &)(void))breakpoint_trap);

	push	OFFSET ?breakpoint_trap@@YAXIII@Z	; breakpoint_trap
	push	3
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 27   : 	setvect(4, (void(__cdecl &)(void))overflow_trap);

	push	OFFSET ?overflow_trap@@YAXIII@Z		; overflow_trap
	push	4
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 28   : 	setvect(5, (void(__cdecl &)(void))bounds_check_fault);

	push	OFFSET ?bounds_check_fault@@YAXIII@Z	; bounds_check_fault
	push	5
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 29   : 	setvect(6, (void(__cdecl &)(void))invalid_opcode_fault);

	push	OFFSET ?invalid_opcode_fault@@YAXIII@Z	; invalid_opcode_fault
	push	6
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 30   : 	setvect(7, (void(__cdecl &)(void))no_device_fault);

	push	OFFSET ?no_device_fault@@YAXIII@Z	; no_device_fault
	push	7
	call	?setvect@@YAXIA6AXXZ@Z			; setvect
	add	esp, 64					; 00000040H

; 31   : 	setvect(8, (void(__cdecl &)(void))double_fault_abort);

	push	OFFSET ?double_fault_abort@@YAXIIII@Z	; double_fault_abort
	push	8
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 32   : 	setvect(10, (void(__cdecl &)(void))invalid_tss_fault);

	push	OFFSET ?invalid_tss_fault@@YAXIIII@Z	; invalid_tss_fault
	push	10					; 0000000aH
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 33   : 	setvect(11, (void(__cdecl &)(void))no_segment_fault);

	push	OFFSET ?no_segment_fault@@YAXIIII@Z	; no_segment_fault
	push	11					; 0000000bH
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 34   : 	setvect(12, (void(__cdecl &)(void))stack_fault);

	push	OFFSET ?stack_fault@@YAXIIII@Z		; stack_fault
	push	12					; 0000000cH
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 35   : 	setvect(13, (void(__cdecl &)(void))general_protection_fault);

	push	OFFSET ?general_protection_fault@@YAXIIII@Z ; general_protection_fault
	push	13					; 0000000dH
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 36   : 	setvect(14, (void(__cdecl &)(void))page_fault);

	push	OFFSET ?page_fault@@YAXIIII@Z		; page_fault
	push	14					; 0000000eH
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 37   : 	setvect(16, (void(__cdecl &)(void))fpu_fault);

	push	OFFSET ?fpu_fault@@YAXIII@Z		; fpu_fault
	push	16					; 00000010H
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 38   : 	setvect(17, (void(__cdecl &)(void))alignment_check_fault);

	push	OFFSET ?alignment_check_fault@@YAXIIII@Z ; alignment_check_fault
	push	17					; 00000011H
	call	?setvect@@YAXIA6AXXZ@Z			; setvect
	add	esp, 64					; 00000040H

; 39   : 	setvect(18, (void(__cdecl &)(void))machine_check_abort);

	push	OFFSET ?machine_check_abort@@YAXIII@Z	; machine_check_abort
	push	18					; 00000012H
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 40   : 	setvect(19, (void(__cdecl &)(void))simd_fpu_fault);

	push	OFFSET ?simd_fpu_fault@@YAXIII@Z	; simd_fpu_fault
	push	19					; 00000013H
	call	?setvect@@YAXIA6AXXZ@Z			; setvect

; 41   : 
; 42   : 	interrupt_enable(); /*Enabling interrupt*/

	call	?interrupt_enable@@YAXXZ		; interrupt_enable

; 43   : 	DebugClrScreen(0x1f);

	push	31					; 0000001fH
	call	?DebugClrScreen@@YAXE@Z			; DebugClrScreen

; 44   : 	DebugSetColor(0x78);

	push	120					; 00000078H
	call	?DebugSetColor@@YAXG@Z			; DebugSetColor

; 45   : 	DebugPuts("    Mango  Operating System is Loading ....                                     ");

	push	OFFSET $SG2828
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 46   : 	DebugSetColor(0x19);

	push	25					; 00000019H
	call	?DebugSetColor@@YAXG@Z			; DebugSetColor

; 47   : 	DebugPuts("we are optimizing th operating system WindowsX!\n");

	push	OFFSET $SG2829
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 48   : 
; 49   : 	unsigned int memory_amount = 1024;
; 50   : 	memory_amount += info->m_memoryLo;
; 51   : 	memory_amount += info->m_memoryHi * 64;

	mov	eax, DWORD PTR _info$[esp+44]
	mov	esi, DWORD PTR [eax+8]
	add	esi, 16					; 00000010H
	shl	esi, 6
	add	esi, DWORD PTR [eax+4]

; 52   : 	DebugPrintf("ram Amount : %d", memory_amount);

	push	esi
	push	OFFSET $SG2831
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf

; 53   : 	pmm_initialize(memory_amount,0x100000+kernel_img_size*512);

	mov	eax, DWORD PTR _kernel_img_size$[esp+56]
	add	eax, 2048				; 00000800H
	shl	eax, 9
	push	eax
	push	esi
	call	?pmm_initialize@@YAXII@Z		; pmm_initialize

; 54   : 
; 55   : 	DebugGotoXY(0, 24);

	push	24					; 00000018H
	push	0
	call	?DebugGotoXY@@YAXEE@Z			; DebugGotoXY

; 56   : 	DebugSetColor(0x78);

	push	120					; 00000078H
	call	?DebugSetColor@@YAXG@Z			; DebugSetColor
	add	esp, 64					; 00000040H

; 57   : 	DebugPuts("CTRL+ALT+DEL to restart                                                         ");

	push	OFFSET $SG2832
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts

; 58   : 
; 59   : 
; 60   : 	memory_region *mem_mep = (memory_region*)0x1000;
; 61   : 	DebugGotoXY(0, 3);

	push	3
	push	0
	call	?DebugGotoXY@@YAXEE@Z			; DebugGotoXY
	add	esp, 12					; 0000000cH
	mov	esi, 4104				; 00001008H

; 62   : 	for (int i = 0; i < 15; i++){

	xor	edi, edi
$LL7@main:

; 63   : 		if (i>0 && mem_mep[i].startLow == 0)

	test	edi, edi
	jle	SHORT $LN4@main
	cmp	DWORD PTR [esi-8], 0
	je	SHORT $LN12@main
$LN4@main:

; 64   : 			break;
; 65   : 		DebugPrintf("Base Frame : %d  and limit Block %d type: %d \n",
; 66   : 			mem_mep[i].startLow / 4096, mem_mep[i].sizeLow / 4096,
; 67   : 			mem_mep[i].type);

	push	DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	shr	eax, 12					; 0000000cH
	push	eax
	mov	eax, DWORD PTR [esi-8]
	shr	eax, 12					; 0000000cH
	push	eax
	push	OFFSET $SG2840
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 16					; 00000010H

; 68   : 		if (mem_mep[i].type == 1)	/*We Can Use it region*/

	cmp	DWORD PTR [esi+8], 1
	jne	SHORT $LN6@main

; 69   : 			 pmm_clr_region(mem_mep[i].startLow, mem_mep[i].sizeLow);

	push	DWORD PTR [esi]
	push	DWORD PTR [esi-8]
	call	?pmm_clr_region@@YAXII@Z		; pmm_clr_region
	add	esp, 8
$LN6@main:

; 62   : 	for (int i = 0; i < 15; i++){

	add	esi, 24					; 00000018H
	inc	edi
	cmp	esi, 4464				; 00001170H
	jl	SHORT $LL7@main
$LN12@main:

; 70   : 	}
; 71   : 	pmm_set_region(0x100000,kernel_img_size*512);

	mov	eax, DWORD PTR _kernel_img_size$[esp+12]
	shl	eax, 9
	push	eax
	push	1048576					; 00100000H
	call	?pmm_set_region@@YAXII@Z		; pmm_set_region

; 72   : 	
; 73   : 	DebugPrintf("Kernel Block : %d \n", kernel_img_size);

	push	DWORD PTR _kernel_img_size$[esp+20]
	push	OFFSET $SG2842
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 16					; 00000010H

; 74   : 
; 75   : 
; 76   : 	DebugPrintf("\npmm regions initialized: %i allocation blocks; used or reserved blocks: %i\nfree blocks: %i\n",
; 77   : 		pmm_get_max_blocks(), pmm_get_used_block_count(), pmm_get_free_block_count());

	call	?pmm_get_free_block_count@@YAIXZ	; pmm_get_free_block_count
	push	eax
	call	?pmm_get_used_block_count@@YAIXZ	; pmm_get_used_block_count
	push	eax
	call	?pmm_get_max_blocks@@YAIXZ		; pmm_get_max_blocks
	push	eax
	push	OFFSET $SG2843
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf

; 78   : 
; 79   : 	//! allocating and deallocating memory examples...
; 80   : 
; 81   : 	DebugSetColor(0x12);

	push	18					; 00000012H
	call	?DebugSetColor@@YAXG@Z			; DebugSetColor

; 82   : 
; 83   : 	uint32_t* p = (uint32_t*)pmm_alloc_block();

	call	?pmm_alloc_block@@YAPAXXZ		; pmm_alloc_block
	mov	esi, eax

; 84   : 	DebugPrintf("\np allocated at frame : %d", uint32_t(p) / 4096);

	mov	ecx, esi
	shr	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET $SG2846
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf

; 85   : 
; 86   : 	uint32_t* p2 = (uint32_t*)pmm_alloc_block_s(2);

	push	2
	call	?pmm_alloc_block_s@@YAPAXI@Z		; pmm_alloc_block_s
	mov	edi, eax

; 87   : 	DebugPrintf("\nallocated 2 blocks for p2 at frame : %d", uint32_t(p2) / 4096);

	mov	ecx, edi
	shr	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET $SG2849
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf

; 88   : 
; 89   : 	uint32_t* p3 = (uint32_t*)pmm_alloc_block();

	call	?pmm_alloc_block@@YAPAXXZ		; pmm_alloc_block

; 90   : 	DebugPrintf("\np allocated at frame : %d", uint32_t(p3) / 4096);

	shr	eax, 12					; 0000000cH
	push	eax
	push	OFFSET $SG2852
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf

; 91   : 
; 92   : 	pmm_free_block(p);

	push	esi
	call	?pmm_free_block@@YAXPAI@Z		; pmm_free_block

; 93   : 	p = (uint32_t*)pmm_alloc_block();

	call	?pmm_alloc_block@@YAPAXXZ		; pmm_alloc_block
	mov	esi, eax

; 94   : 	DebugPrintf("\nUnallocated p to free block 1. p is reallocated to frame : %d", uint32_t(p) / 4096);

	mov	ecx, esi
	shr	ecx, 12					; 0000000cH
	push	ecx
	push	OFFSET $SG2854
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf

; 95   : 
; 96   : 	pmm_free_block(p);

	push	esi
	call	?pmm_free_block@@YAXPAI@Z		; pmm_free_block
	add	esp, 64					; 00000040H

; 97   : 	pmm_free_block_s(p2, 2);

	push	2
	push	edi
	call	?pmm_free_block_s@@YAXPAII@Z		; pmm_free_block_s
	add	esp, 8
$LL2@main:

; 98   : 
; 99   : 
; 100  : 	for (;;){
; 101  : 		DebugGotoXY(0, 23);

	push	23					; 00000017H
	push	0
	call	?DebugGotoXY@@YAXEE@Z			; DebugGotoXY

; 102  : 		DebugPrintf("Count = %d", get_tick());

	call	?get_tick@@YAIXZ			; get_tick
	push	eax
	push	OFFSET $SG2858
	call	?DebugPrintf@@YAHPBDZZ			; DebugPrintf
	add	esp, 16					; 00000010H

; 103  : 	}

	jmp	SHORT $LL2@main
_main	ENDP
_TEXT	ENDS
END
