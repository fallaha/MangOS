; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Ali\Desktop\OperatingSystem\SystemCore\SysCore\Kernel\DebugDisplay.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?_curX@@3EA					; _curX
PUBLIC	?_curY@@3EA					; _curY
PUBLIC	?video_memory@@3PAGA				; video_memory
PUBLIC	?_color@@3GA					; _color
PUBLIC	?tbuf@@3PADA					; tbuf
PUBLIC	?bchars@@3PADA					; bchars
PUBLIC	?Debugstr@@3PADA				; Debugstr
_BSS	SEGMENT
?_curX@@3EA DB	01H DUP (?)				; _curX
	ALIGN	4

?_curY@@3EA DB	01H DUP (?)				; _curY
	ALIGN	4

?tbuf@@3PADA DB	020H DUP (?)				; tbuf
?Debugstr@@3PADA DB 020H DUP (?)			; Debugstr
_BSS	ENDS
_DATA	SEGMENT
?video_memory@@3PAGA DD 0b8000H				; video_memory
?_color@@3GA DW	01fH					; _color
	ORG $+2
?bchars@@3PADA DB 030H					; bchars
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	041H
	DB	042H
	DB	043H
	DB	044H
	DB	045H
	DB	046H
_DATA	ENDS
PUBLIC	?DebugPutc@@YAXE@Z				; DebugPutc
PUBLIC	?DebugGotoXY@@YAXEE@Z				; DebugGotoXY
PUBLIC	?DebugClrScreen@@YAXE@Z				; DebugClrScreen
PUBLIC	?DebugSetColor@@YAXG@Z				; DebugSetColor
PUBLIC	?DebugPuts@@YAXPAD@Z				; DebugPuts
PUBLIC	?DebugPrintf@@YAHPBDZZ				; DebugPrintf
PUBLIC	?itoa@@YAXIIPAD@Z				; itoa
PUBLIC	?itoa_s@@YAXHIPAD@Z				; itoa_s
EXTRN	?strcpy@@YAPADPADPBD@Z:PROC			; strcpy
EXTRN	?strlen@@YAIPBD@Z:PROC				; strlen
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\operatingsystem\systemcore\syscore\kernel\debugdisplay.cpp
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 4
_buf$ = 16						; size = 4
?itoa_s@@YAXHIPAD@Z PROC				; itoa_s

; 90   : 	if (base > 16) return;

	mov	edx, DWORD PTR _base$[esp-4]
	cmp	edx, 16					; 00000010H
	ja	SHORT $LN3@itoa_s

; 91   : 	if (i < 0) {

	mov	eax, DWORD PTR _i$[esp-4]

; 92   : 		*buf++ = '-';

	mov	ecx, DWORD PTR _buf$[esp-4]
	test	eax, eax
	jns	SHORT $LN1@itoa_s
	mov	BYTE PTR [ecx], 45			; 0000002dH
	inc	ecx

; 93   : 		i *= -1;

	neg	eax
$LN1@itoa_s:

; 94   : 	}
; 95   : 	itoa(i, base, buf);

	mov	DWORD PTR _buf$[esp-4], ecx
	mov	DWORD PTR _base$[esp-4], edx
	mov	DWORD PTR _i$[esp-4], eax
	jmp	?itoa@@YAXIIPAD@Z			; itoa
$LN3@itoa_s:

; 96   : }

	ret	0
?itoa_s@@YAXHIPAD@Z ENDP				; itoa_s
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\operatingsystem\systemcore\syscore\kernel\debugdisplay.cpp
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 4
_buf$ = 16						; size = 4
?itoa@@YAXIIPAD@Z PROC					; itoa

; 66   : void itoa(unsigned i, unsigned base, char* buf) {

	push	esi

; 67   : 	int pos = 0;
; 68   : 	int opos = 0;
; 69   : 	int top = 0;
; 70   : 
; 71   : 	if (i == 0 || base > 16) {

	mov	esi, DWORD PTR _i$[esp]
	xor	ecx, ecx
	push	edi
	test	esi, esi
	je	SHORT $LN6@itoa
	mov	edi, DWORD PTR _base$[esp+4]
	cmp	edi, 16					; 00000010H
	ja	SHORT $LN6@itoa
$LL5@itoa:

; 73   : 		buf[1] = '\0';
; 74   : 		return;
; 75   : 	}
; 76   : 
; 77   : 	while (i != 0) {
; 78   : 		tbuf[pos] = bchars[i % base];

	mov	eax, esi
	xor	edx, edx
	div	edi
	mov	esi, eax
	mov	al, BYTE PTR ?bchars@@3PADA[edx]
	mov	BYTE PTR ?tbuf@@3PADA[ecx], al

; 79   : 		pos++;

	inc	ecx
	test	esi, esi
	jne	SHORT $LL5@itoa

; 83   : 	for (opos = 0; opos<top; pos--, opos++) {

	mov	esi, DWORD PTR _buf$[esp+4]
	mov	edi, ecx
	xor	eax, eax
	test	edi, edi
	jle	SHORT $LN1@itoa

; 80   : 		i /= base;
; 81   : 	}
; 82   : 	top = pos--;

	lea	edx, DWORD PTR ?tbuf@@3PADA[ecx-1]
$LL3@itoa:

; 84   : 		buf[opos] = tbuf[pos];

	mov	cl, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx-1]
	mov	BYTE PTR [eax+esi], cl
	inc	eax
	cmp	eax, edi
	jl	SHORT $LL3@itoa
$LN1@itoa:
	pop	edi

; 85   : 	}
; 86   : 	buf[opos] = 0;

	mov	BYTE PTR [eax+esi], 0
	pop	esi

; 87   : }

	ret	0
$LN6@itoa:

; 72   : 		buf[0] = '0';

	mov	eax, DWORD PTR _buf$[esp+4]
	pop	edi
	pop	esi
	mov	WORD PTR [eax], 48			; 00000030H

; 87   : }

	ret	0
?itoa@@YAXIIPAD@Z ENDP					; itoa
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\operatingsystem\systemcore\syscore\kernel\debugdisplay.cpp
_TEXT	SEGMENT
tv443 = -4						; size = 4
_str$ = 8						; size = 4
?DebugPrintf@@YAHPBDZZ PROC				; DebugPrintf

; 100  : int DebugPrintf(const char* str, ...) {

	push	ecx
	push	ebp

; 101  : 
; 102  : 	if (!str)

	mov	ebp, DWORD PTR _str$[esp+4]
	test	ebp, ebp
	jne	SHORT $LN15@DebugPrint

; 103  : 		return 0;

	xor	eax, eax
	pop	ebp

; 170  : }

	pop	ecx
	ret	0
$LN15@DebugPrint:
	push	ebx
	push	esi
	push	edi

; 107  : 	size_t i;
; 108  : 	for (i = 0; i<strlen(str); i++) {

	push	ebp
	xor	esi, esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	test	eax, eax
	je	$LN12@DebugPrint

; 104  : 
; 105  : 	va_list		args;
; 106  : 	va_start(args, str);

	lea	ecx, DWORD PTR _str$[esp+16]
	mov	DWORD PTR tv443[esp+20], ecx
	npad	3
$LL14@DebugPrint:

; 109  : 
; 110  : 		switch (str[i]) {

	mov	al, BYTE PTR [esi+ebp]
	cmp	al, 37					; 00000025H
	je	SHORT $LN9@DebugPrint

; 157  : 			}
; 158  : 
; 159  : 			break;
; 160  : 
; 161  : 		default:
; 162  : 			DebugPutc(str[i]);

	push	eax
	call	?DebugPutc@@YAXE@Z			; DebugPutc
	add	esp, 4

; 163  : 			break;

	jmp	$LN13@DebugPrint
$LN9@DebugPrint:

; 111  : 
; 112  : 		case '%':
; 113  : 
; 114  : 			switch (str[i + 1]) {

	movsx	eax, BYTE PTR [esi+ebp+1]
	add	eax, -88				; ffffffa8H
	cmp	eax, 32					; 00000020H
	ja	$LN2@DebugPrint
	movzx	eax, BYTE PTR $LN64@DebugPrint[eax]
	jmp	DWORD PTR $LN71@DebugPrint[eax*4]
$LN6@DebugPrint:

; 115  : 
; 116  : 				/*** characters ***/
; 117  : 			case 'c': {
; 118  : 				char c = va_arg(args, char);
; 119  : 				DebugPutc(c);

	movzx	eax, BYTE PTR [ecx+4]
	add	ecx, 4
	push	eax
	mov	DWORD PTR tv443[esp+24], ecx
	call	?DebugPutc@@YAXE@Z			; DebugPutc

; 120  : 				i++;		// go to next character
; 121  : 				break;

	jmp	$LN68@DebugPrint
$LN5@DebugPrint:

; 122  : 			}
; 123  : 
; 124  : 					  /*** address of ***/
; 125  : 			case 's': {
; 126  : 				int c = (int&)va_arg(args, char);
; 127  : 				strcpy(Debugstr, (const char*)c);

	push	DWORD PTR [ecx+4]
	add	ecx, 4
	push	OFFSET ?Debugstr@@3PADA			; Debugstr
	mov	DWORD PTR tv443[esp+28], ecx
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 128  : 				DebugPuts(Debugstr);

	push	OFFSET ?Debugstr@@3PADA			; Debugstr
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
	add	esp, 12					; 0000000cH

; 129  : 				i++;		// go to next character
; 130  : 				break;

	jmp	$LN69@DebugPrint
$LN4@DebugPrint:

; 131  : 			}
; 132  : 
; 133  : 					  /*** integers ***/
; 134  : 			case 'd':
; 135  : 			case 'i': {
; 136  : 				int c = va_arg(args, int);

	add	ecx, 4

; 137  : 
; 138  : 				itoa_s(c, 10, Debugstr);

	mov	ebx, OFFSET ?Debugstr@@3PADA		; Debugstr
	mov	DWORD PTR tv443[esp+20], ecx
	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	jns	SHORT $LN18@DebugPrint
	mov	BYTE PTR ?Debugstr@@3PADA, 45		; 0000002dH
	mov	ebx, OFFSET ?Debugstr@@3PADA+1
	neg	ecx
$LN18@DebugPrint:
	xor	edi, edi
	test	ecx, ecx
	je	SHORT $LN27@DebugPrint
$LL26@DebugPrint:
	mov	eax, -858993459				; cccccccdH
	mul	ecx
	shr	edx, 3
	lea	eax, DWORD PTR [edx+edx*4]
	add	eax, eax
	sub	ecx, eax
	mov	al, BYTE PTR ?bchars@@3PADA[ecx]
	mov	ecx, edx
	mov	BYTE PTR ?tbuf@@3PADA[edi], al
	inc	edi
	test	ecx, ecx
	jne	SHORT $LL26@DebugPrint
	mov	ebp, edi
	test	ebp, ebp
	jle	SHORT $LN22@DebugPrint
	lea	edx, DWORD PTR ?tbuf@@3PADA[edi-1]
$LL24@DebugPrint:
	mov	al, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx-1]
	mov	BYTE PTR [ecx+ebx], al
	inc	ecx
	cmp	ecx, ebp
	jl	SHORT $LL24@DebugPrint
$LN22@DebugPrint:
	mov	ebp, DWORD PTR _str$[esp+16]
	mov	BYTE PTR [ecx+ebx], 0
	jmp	SHORT $LN42@DebugPrint
$LN27@DebugPrint:
	mov	WORD PTR [ebx], 48			; 00000030H

; 139  : 				DebugPuts(Debugstr);
; 140  : 				i++;		// go to next character
; 141  : 				break;

	jmp	SHORT $LN42@DebugPrint
$LN3@DebugPrint:

; 142  : 			}
; 143  : 
; 144  : 					  /*** display in hex ***/
; 145  : 			case 'X':
; 146  : 			case 'x': {
; 147  : 				int c = va_arg(args, int);
; 148  : 				itoa_s(c, 16, Debugstr);

	mov	eax, DWORD PTR [ecx+4]
	add	ecx, 4
	mov	DWORD PTR tv443[esp+20], ecx
	mov	edi, OFFSET ?Debugstr@@3PADA		; Debugstr
	test	eax, eax
	jns	SHORT $LN31@DebugPrint
	mov	BYTE PTR ?Debugstr@@3PADA, 45		; 0000002dH
	mov	edi, OFFSET ?Debugstr@@3PADA+1
	neg	eax
$LN31@DebugPrint:
	xor	edx, edx
	test	eax, eax
	je	SHORT $LN40@DebugPrint
	npad	5
$LL39@DebugPrint:
	mov	ecx, eax
	shr	eax, 4
	and	ecx, 15					; 0000000fH
	mov	cl, BYTE PTR ?bchars@@3PADA[ecx]
	mov	BYTE PTR ?tbuf@@3PADA[edx], cl
	inc	edx
	test	eax, eax
	jne	SHORT $LL39@DebugPrint
	mov	ebx, edx
	xor	ecx, ecx
	test	ebx, ebx
	jle	SHORT $LN35@DebugPrint
	lea	edx, DWORD PTR ?tbuf@@3PADA[edx-1]
$LL37@DebugPrint:
	mov	al, BYTE PTR [edx]
	lea	edx, DWORD PTR [edx-1]
	mov	BYTE PTR [ecx+edi], al
	inc	ecx
	cmp	ecx, ebx
	jl	SHORT $LL37@DebugPrint
$LN35@DebugPrint:
	mov	BYTE PTR [ecx+edi], 0
	jmp	SHORT $LN42@DebugPrint
$LN40@DebugPrint:
	mov	WORD PTR [edi], 48			; 00000030H
$LN42@DebugPrint:

; 149  : 				DebugPuts(Debugstr);

	push	OFFSET ?Debugstr@@3PADA			; Debugstr
	call	?DebugPuts@@YAXPAD@Z			; DebugPuts
$LN68@DebugPrint:
	add	esp, 4
$LN69@DebugPrint:

; 150  : 				i++;		// go to next character

	inc	esi
$LN13@DebugPrint:

; 107  : 	size_t i;
; 108  : 	for (i = 0; i<strlen(str); i++) {

	push	ebp
	inc	esi
	call	?strlen@@YAIPBD@Z			; strlen
	mov	ecx, DWORD PTR tv443[esp+24]
	add	esp, 4
	cmp	esi, eax
	jb	$LL14@DebugPrint
$LN12@DebugPrint:
	pop	edi

; 164  : 		}
; 165  : 
; 166  : 	}
; 167  : 
; 168  : 	va_end(args);
; 169  : 	return i;

	mov	eax, esi
	pop	esi
	pop	ebx
	pop	ebp

; 170  : }

	pop	ecx
	ret	0
$LN2@DebugPrint:
	pop	edi
	pop	esi
	pop	ebx

; 151  : 				break;
; 152  : 			}
; 153  : 
; 154  : 			default:
; 155  : 				va_end(args);
; 156  : 				return 1;

	mov	eax, 1
	pop	ebp

; 170  : }

	pop	ecx
	ret	0
	npad	2
$LN71@DebugPrint:
	DD	$LN3@DebugPrint
	DD	$LN6@DebugPrint
	DD	$LN4@DebugPrint
	DD	$LN5@DebugPrint
	DD	$LN2@DebugPrint
$LN64@DebugPrint:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
?DebugPrintf@@YAHPBDZZ ENDP				; DebugPrintf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\operatingsystem\systemcore\syscore\kernel\debugdisplay.cpp
_TEXT	SEGMENT
_s$ = 8							; size = 4
?DebugPuts@@YAXPAD@Z PROC				; DebugPuts

; 56   : void DebugPuts(char * s){

	push	esi

; 57   : 	while (*s)

	mov	esi, DWORD PTR _s$[esp]
	mov	dl, BYTE PTR [esi]
	test	dl, dl
	je	$LN1@DebugPuts
	mov	al, BYTE PTR ?_curX@@3EA		; _curX
	push	ebx
	mov	bl, BYTE PTR ?_curY@@3EA		; _curY
	npad	5
$LL2@DebugPuts:

; 58   : 		DebugPutc(*s++);

	mov	ecx, DWORD PTR ?_color@@3GA		; _color
	shl	ecx, 8
	movzx	ecx, cx
	cmp	dl, 10					; 0000000aH
	je	SHORT $LN21@DebugPuts
	cmp	dl, 8
	jne	SHORT $LN12@DebugPuts
	test	al, al
	je	SHORT $LN6@DebugPuts
	dec	al
	jmp	SHORT $LN22@DebugPuts
$LN12@DebugPuts:
	cmp	dl, 13					; 0000000dH
	jne	SHORT $LN10@DebugPuts
	xor	al, al
	jmp	SHORT $LN23@DebugPuts
$LN10@DebugPuts:
	cmp	dl, 9
	jne	SHORT $LN8@DebugPuts
	add	al, 8
	jmp	SHORT $LN22@DebugPuts
$LN8@DebugPuts:
	cmp	dl, 32					; 00000020H
	jb	SHORT $LN6@DebugPuts
	movzx	edx, dl
	or	dx, cx
	movzx	eax, al
	movzx	ecx, bl
	lea	ecx, DWORD PTR [ecx+ecx*4]
	shl	ecx, 4
	add	ecx, eax
	mov	eax, DWORD PTR ?video_memory@@3PAGA	; video_memory
	mov	WORD PTR [eax+ecx*2], dx
	mov	al, BYTE PTR ?_curX@@3EA		; _curX
	mov	bl, BYTE PTR ?_curY@@3EA		; _curY
	inc	al
$LN22@DebugPuts:
	mov	BYTE PTR ?_curX@@3EA, al		; _curX
$LN6@DebugPuts:
	cmp	al, 80					; 00000050H
	jb	SHORT $LN5@DebugPuts
$LN21@DebugPuts:
	xor	al, al
	inc	bl
	mov	BYTE PTR ?_curY@@3EA, bl		; _curY
$LN23@DebugPuts:
	mov	BYTE PTR ?_curX@@3EA, al		; _curX
$LN5@DebugPuts:
	mov	dl, BYTE PTR [esi+1]
	inc	esi
	test	dl, dl
	jne	SHORT $LL2@DebugPuts
	pop	ebx
$LN1@DebugPuts:
	pop	esi

; 59   : }

	ret	0
?DebugPuts@@YAXPAD@Z ENDP				; DebugPuts
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\operatingsystem\systemcore\syscore\kernel\debugdisplay.cpp
_TEXT	SEGMENT
_color$ = 8						; size = 2
?DebugSetColor@@YAXG@Z PROC				; DebugSetColor

; 38   : 	_color = color;

	mov	eax, DWORD PTR _color$[esp-4]
	mov	WORD PTR ?_color@@3GA, ax		; _color

; 39   : }

	ret	0
?DebugSetColor@@YAXG@Z ENDP				; DebugSetColor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\operatingsystem\systemcore\syscore\kernel\debugdisplay.cpp
_TEXT	SEGMENT
_bgcolor$ = 8						; size = 1
?DebugClrScreen@@YAXE@Z PROC				; DebugClrScreen

; 41   : void DebugClrScreen(unsigned char bgcolor){

	mov	eax, DWORD PTR _bgcolor$[esp-4]

; 42   : 	DebugGotoXY(0, 0);
; 43   : 	uint16_t *loc;
; 44   : 	loc = video_memory;
; 45   : 	for (int i = 0; i < 25 * 80; i++)
; 46   : 		loc[i] = ' ' | (bgcolor << 8);

	mov	ecx, 1000				; 000003e8H
	movzx	eax, al
	shl	ax, 8
	or	eax, 32					; 00000020H
	mov	BYTE PTR ?_curX@@3EA, 0			; _curX
	movzx	edx, ax
	mov	eax, edx
	mov	BYTE PTR ?_curY@@3EA, 0			; _curY
	push	edi
	mov	edi, DWORD PTR ?video_memory@@3PAGA	; video_memory
	shl	edx, 16					; 00000010H
	or	eax, edx
	rep stosd
	pop	edi

; 47   : }

	ret	0
?DebugClrScreen@@YAXE@Z ENDP				; DebugClrScreen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\operatingsystem\systemcore\syscore\kernel\debugdisplay.cpp
_TEXT	SEGMENT
_x$ = 8							; size = 1
_y$ = 12						; size = 1
?DebugGotoXY@@YAXEE@Z PROC				; DebugGotoXY

; 51   : 	_curX = x;

	mov	eax, DWORD PTR _x$[esp-4]
	mov	BYTE PTR ?_curX@@3EA, al		; _curX

; 52   : 	_curY = y;

	mov	eax, DWORD PTR _y$[esp-4]
	mov	BYTE PTR ?_curY@@3EA, al		; _curY

; 53   : 
; 54   : }

	ret	0
?DebugGotoXY@@YAXEE@Z ENDP				; DebugGotoXY
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\operatingsystem\systemcore\syscore\kernel\debugdisplay.cpp
_TEXT	SEGMENT
_ch$ = 8						; size = 1
?DebugPutc@@YAXE@Z PROC					; DebugPutc

; 13   : 	uint16_t attribute = _color << 8;

	mov	eax, DWORD PTR ?_color@@3GA		; _color
	shl	eax, 8
	movzx	ecx, ax

; 14   : 	if (ch == 0x0A){ /*next Line*/

	mov	al, BYTE PTR _ch$[esp-4]
	cmp	al, 10					; 0000000aH
	je	SHORT $LN14@DebugPutc

; 15   : 		_curX = 0;
; 16   : 		_curY++;
; 17   : 	}
; 18   : 	else if (ch == 0x08 && _curX) /*BackSpace*/

	cmp	al, 8
	jne	SHORT $LN8@DebugPutc
	mov	al, BYTE PTR ?_curX@@3EA		; _curX
	test	al, al
	je	SHORT $LN2@DebugPutc

; 19   : 		_curX--;

	dec	al
	mov	BYTE PTR ?_curX@@3EA, al		; _curX
	jmp	SHORT $LN2@DebugPutc
$LN8@DebugPutc:

; 20   : 	else if (ch == '\r') /*return*/

	cmp	al, 13					; 0000000dH
	je	SHORT $LN15@DebugPutc

; 21   : 		_curX = 0;
; 22   : 	else if (ch == 0x09)

	cmp	al, 9
	jne	SHORT $LN4@DebugPutc

; 23   : 		_curX += 8;

	mov	al, BYTE PTR ?_curX@@3EA		; _curX
	add	al, 8
	mov	BYTE PTR ?_curX@@3EA, al		; _curX
	jmp	SHORT $LN2@DebugPutc
$LN4@DebugPutc:

; 24   : 	else if (ch >= ' '){ /*ASSCI : 32 */

	cmp	al, 32					; 00000020H
	jb	SHORT $LN13@DebugPutc

; 25   : 		uint16_t * location = (uint16_t *)(video_memory + (_curX + _curY * 80));
; 26   : 		*location = ch | attribute;

	movzx	edx, al
	movzx	eax, BYTE PTR ?_curY@@3EA		; _curY
	or	dx, cx
	lea	ecx, DWORD PTR [eax+eax*4]
	movzx	eax, BYTE PTR ?_curX@@3EA		; _curX
	shl	ecx, 4
	add	ecx, eax
	mov	eax, DWORD PTR ?video_memory@@3PAGA	; video_memory
	mov	WORD PTR [eax+ecx*2], dx

; 27   : 		_curX++;

	mov	al, BYTE PTR ?_curX@@3EA		; _curX
	inc	al
	mov	BYTE PTR ?_curX@@3EA, al		; _curX
	jmp	SHORT $LN2@DebugPutc
$LN13@DebugPutc:
	mov	al, BYTE PTR ?_curX@@3EA		; _curX
$LN2@DebugPutc:

; 28   : 	}
; 29   : 
; 30   : 	if (_curX >= 80){

	cmp	al, 80					; 00000050H
	jb	SHORT $LN1@DebugPutc
$LN14@DebugPutc:

; 32   : 		_curY++;

	inc	BYTE PTR ?_curY@@3EA			; _curY
$LN15@DebugPutc:

; 31   : 		_curX = 0;

	mov	BYTE PTR ?_curX@@3EA, 0			; _curX
$LN1@DebugPutc:

; 33   : 	}
; 34   : 
; 35   : }

	ret	0
?DebugPutc@@YAXE@Z ENDP					; DebugPutc
_TEXT	ENDS
END
