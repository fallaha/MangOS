; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Ali\Desktop\MangOS\SystemCore\SysCore\Kernel\vmm.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	?vmm_load_pdbr@@YAXPAUpdir@@@Z			; vmm_load_pdbr
PUBLIC	?vmm_get_cur_dir@@YAPAUpdir@@XZ			; vmm_get_cur_dir
PUBLIC	?vmm_alloc_frame@@YA_NPAI@Z			; vmm_alloc_frame
PUBLIC	?vmm_free_frame@@YA_NPAI@Z			; vmm_free_frame
PUBLIC	?vmm_map_page@@YAXPAX0@Z			; vmm_map_page
PUBLIC	?vmm_initialize@@YAXXZ				; vmm_initialize
PUBLIC	?vmm_mapPhysicalAddress@@YAXPAUpdir@@III@Z	; vmm_mapPhysicalAddress
PUBLIC	?vmmngr_createPageTable@@YAHPAUpdir@@II@Z	; vmmngr_createPageTable
PUBLIC	?vmm_pd_entry_add_attrib@@YAXPAII@Z		; vmm_pd_entry_add_attrib
PUBLIC	?vmm_pd_entry_del_attrib@@YAXPAII@Z		; vmm_pd_entry_del_attrib
PUBLIC	?vmm_pd_entry_set_frame@@YAXPAII@Z		; vmm_pd_entry_set_frame
PUBLIC	?vmm_pd_entry_is_present@@YA_NI@Z		; vmm_pd_entry_is_present
PUBLIC	?vmm_pd_entry_is_user@@YA_NI@Z			; vmm_pd_entry_is_user
PUBLIC	?vmm_pd_entry_is_4mb@@YA_NI@Z			; vmm_pd_entry_is_4mb
PUBLIC	?vmm_pt_entry_add_attrib@@YAXPAII@Z		; vmm_pt_entry_add_attrib
PUBLIC	?vmm_pt_entry_del_attrib@@YAXPAII@Z		; vmm_pt_entry_del_attrib
PUBLIC	?vmm_pt_entry_set_frame@@YAXPAII@Z		; vmm_pt_entry_set_frame
PUBLIC	?vmm_pt_entry_is_present@@YA_NI@Z		; vmm_pt_entry_is_present
PUBLIC	?vmm_pt_entry_is_writable@@YA_NI@Z		; vmm_pt_entry_is_writable
PUBLIC	?vmm_paging_enable@@YAX_N@Z			; vmm_paging_enable
PUBLIC	?vmm_pd_switch@@YA_NPAUpdir@@@Z			; vmm_pd_switch
PUBLIC	?vmm_flush_tlb_entry@@YAXI@Z			; vmm_flush_tlb_entry
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
EXTRN	?pmm_alloc_block@@YAPAXXZ:PROC			; pmm_alloc_block
EXTRN	?pmm_free_block@@YAXPAX@Z:PROC			; pmm_free_block
_BSS	SEGMENT
__vmm_cur_dir DD 01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_flush_tlb_entry@@YAXI@Z
_TEXT	SEGMENT
_addr$ = 8						; size = 4
?vmm_flush_tlb_entry@@YAXI@Z PROC			; vmm_flush_tlb_entry, COMDAT

; 35   : 	_asm{
; 36   : 		cli

	cli

; 37   : 			invlpg addr

	invlpg	DWORD PTR _addr$[esp-4]

; 38   : 			sti

	sti

; 39   : 	}
; 40   : }

	ret	0
?vmm_flush_tlb_entry@@YAXI@Z ENDP			; vmm_flush_tlb_entry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pd_switch@@YA_NPAUpdir@@@Z
_TEXT	SEGMENT
_dir$ = 8						; size = 4
_pd$ = 8						; size = 4
?vmm_pd_switch@@YA_NPAUpdir@@@Z PROC			; vmm_pd_switch, COMDAT

; 26   : 	if (!pd)

	mov	eax, DWORD PTR _pd$[esp-4]
	test	eax, eax
	jne	SHORT $LN1@vmm_pd_swi

; 27   : 		return false;

	xor	al, al

; 32   : }

	ret	0
$LN1@vmm_pd_swi:

; 28   : 
; 29   : 	_vmm_cur_dir = pd;

	mov	DWORD PTR __vmm_cur_dir, eax

; 30   : 	vmm_load_pdbr((pdir*)&_vmm_cur_dir->entry);

	mov	DWORD PTR _dir$[esp-4], eax
	mov	eax, DWORD PTR _dir$[esp-4]
	mov	cr3, eax

; 31   : 	return true;

	mov	al, 1

; 32   : }

	ret	0
?vmm_pd_switch@@YA_NPAUpdir@@@Z ENDP			; vmm_pd_switch
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_paging_enable@@YAX_N@Z
_TEXT	SEGMENT
_b$ = 8							; size = 1
?vmm_paging_enable@@YAX_N@Z PROC			; vmm_paging_enable, COMDAT

; 122  : void vmm_paging_enable(bool b){

	push	ebp
	mov	ebp, esp

; 123  : 	_asm {
; 124  : 		mov eax, cr0

	mov	eax, cr0

; 125  : 			cmp byte ptr[b], 1

	cmp	BYTE PTR _b$[ebp], 1

; 126  : 			jnz fal

	jne	SHORT $fal$4

; 127  : 			or eax, 0x80000000; Bit 31 (PG) : Enables Memory Paging.

	or	eax, -2147483648			; 80000000H

; 128  : 			jmp set

	jmp	SHORT $set$5
$fal$4:

; 129  : 		fal :
; 130  : 		and eax, 0x7FFFFFFF; clear Bit 31 (PG) : Enables Memory Paging.

	and	eax, 2147483647				; 7fffffffH
$set$5:

; 131  : 		set :
; 132  : 			mov cr0, eax

	mov	cr0, eax

; 133  : 	}
; 134  : }

	pop	ebp
	ret	0
?vmm_paging_enable@@YAX_N@Z ENDP			; vmm_paging_enable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pt_entry_is_writable@@YA_NI@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmm_pt_entry_is_writable@@YA_NI@Z PROC			; vmm_pt_entry_is_writable, COMDAT

; 162  : 	return e & VMM_PT_ENTRY_WRITABLE;

	mov	eax, DWORD PTR _e$[esp-4]
	shr	eax, 1
	and	al, 1

; 163  : }

	ret	0
?vmm_pt_entry_is_writable@@YA_NI@Z ENDP			; vmm_pt_entry_is_writable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pt_entry_is_present@@YA_NI@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmm_pt_entry_is_present@@YA_NI@Z PROC			; vmm_pt_entry_is_present, COMDAT

; 158  : 	return e & VMM_PT_ENTRY_PRESENT;

	mov	eax, DWORD PTR _e$[esp-4]
	and	eax, 1

; 159  : }

	ret	0
?vmm_pt_entry_is_present@@YA_NI@Z ENDP			; vmm_pt_entry_is_present
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pt_entry_set_frame@@YAXPAII@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
_addr$ = 12						; size = 4
?vmm_pt_entry_set_frame@@YAXPAII@Z PROC			; vmm_pt_entry_set_frame, COMDAT

; 154  : 	*e = (*e & ~VMM_PT_ENTRY_FRAME) | addr;

	mov	ecx, DWORD PTR _e$[esp-4]
	mov	eax, DWORD PTR [ecx]
	and	eax, -2147479553			; 80000fffH
	or	eax, DWORD PTR _addr$[esp-4]
	mov	DWORD PTR [ecx], eax

; 155  : }

	ret	0
?vmm_pt_entry_set_frame@@YAXPAII@Z ENDP			; vmm_pt_entry_set_frame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pt_entry_del_attrib@@YAXPAII@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
_attrib$ = 12						; size = 4
?vmm_pt_entry_del_attrib@@YAXPAII@Z PROC		; vmm_pt_entry_del_attrib, COMDAT

; 150  : 	*e &= ~attrib;

	mov	eax, DWORD PTR _e$[esp-4]
	mov	ecx, DWORD PTR _attrib$[esp-4]
	not	ecx
	and	DWORD PTR [eax], ecx

; 151  : }

	ret	0
?vmm_pt_entry_del_attrib@@YAXPAII@Z ENDP		; vmm_pt_entry_del_attrib
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pt_entry_add_attrib@@YAXPAII@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
_attrib$ = 12						; size = 4
?vmm_pt_entry_add_attrib@@YAXPAII@Z PROC		; vmm_pt_entry_add_attrib, COMDAT

; 146  : 	*e |= attrib;

	mov	ecx, DWORD PTR _e$[esp-4]
	mov	eax, DWORD PTR _attrib$[esp-4]
	or	DWORD PTR [ecx], eax

; 147  : }

	ret	0
?vmm_pt_entry_add_attrib@@YAXPAII@Z ENDP		; vmm_pt_entry_add_attrib
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pd_entry_is_4mb@@YA_NI@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmm_pd_entry_is_4mb@@YA_NI@Z PROC			; vmm_pd_entry_is_4mb, COMDAT

; 190  : 	return e & VMM_PD_ENTRY_4MB;

	mov	eax, DWORD PTR _e$[esp-4]
	shr	eax, 7
	and	al, 1

; 191  : }

	ret	0
?vmm_pd_entry_is_4mb@@YA_NI@Z ENDP			; vmm_pd_entry_is_4mb
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pd_entry_is_user@@YA_NI@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmm_pd_entry_is_user@@YA_NI@Z PROC			; vmm_pd_entry_is_user, COMDAT

; 186  : 	return e & VMM_PD_ENTRY_USER;

	mov	eax, DWORD PTR _e$[esp-4]
	shr	eax, 2
	and	al, 1

; 187  : }

	ret	0
?vmm_pd_entry_is_user@@YA_NI@Z ENDP			; vmm_pd_entry_is_user
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pd_entry_is_present@@YA_NI@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmm_pd_entry_is_present@@YA_NI@Z PROC			; vmm_pd_entry_is_present, COMDAT

; 178  : 	return e & VMM_PD_ENTRY_PRESENT;

	mov	eax, DWORD PTR _e$[esp-4]
	and	eax, 1

; 179  : }

	ret	0
?vmm_pd_entry_is_present@@YA_NI@Z ENDP			; vmm_pd_entry_is_present
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pd_entry_set_frame@@YAXPAII@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
_addr$ = 12						; size = 4
?vmm_pd_entry_set_frame@@YAXPAII@Z PROC			; vmm_pd_entry_set_frame, COMDAT

; 174  : 	*e = (*e & ~VMM_PD_ENTRY_FRAME) | addr;

	mov	ecx, DWORD PTR _e$[esp-4]
	mov	eax, DWORD PTR [ecx]
	and	eax, -2147479553			; 80000fffH
	or	eax, DWORD PTR _addr$[esp-4]
	mov	DWORD PTR [ecx], eax

; 175  : }

	ret	0
?vmm_pd_entry_set_frame@@YAXPAII@Z ENDP			; vmm_pd_entry_set_frame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pd_entry_del_attrib@@YAXPAII@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
_attrib$ = 12						; size = 4
?vmm_pd_entry_del_attrib@@YAXPAII@Z PROC		; vmm_pd_entry_del_attrib, COMDAT

; 170  : 	*e &= ~attrib;

	mov	eax, DWORD PTR _e$[esp-4]
	mov	ecx, DWORD PTR _attrib$[esp-4]
	not	ecx
	and	DWORD PTR [eax], ecx

; 171  : }

	ret	0
?vmm_pd_entry_del_attrib@@YAXPAII@Z ENDP		; vmm_pd_entry_del_attrib
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_pd_entry_add_attrib@@YAXPAII@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
_attrib$ = 12						; size = 4
?vmm_pd_entry_add_attrib@@YAXPAII@Z PROC		; vmm_pd_entry_add_attrib, COMDAT

; 166  : 	*e |= attrib;

	mov	ecx, DWORD PTR _e$[esp-4]
	mov	eax, DWORD PTR _attrib$[esp-4]
	or	DWORD PTR [ecx], eax

; 167  : }

	ret	0
?vmm_pd_entry_add_attrib@@YAXPAII@Z ENDP		; vmm_pd_entry_add_attrib
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmmngr_createPageTable@@YAHPAUpdir@@II@Z
_TEXT	SEGMENT
_dir$ = 8						; size = 4
_virt$ = 12						; size = 4
_flags$ = 16						; size = 4
?vmmngr_createPageTable@@YAHPAUpdir@@II@Z PROC		; vmmngr_createPageTable, COMDAT

; 206  : 
; 207  : 	pd_entry* pagedir = dir->entry;
; 208  : 	if (pagedir[virt >> 22] == 0) {

	mov	eax, DWORD PTR _virt$[esp-4]
	push	ebp
	push	esi
	push	edi
	mov	edi, DWORD PTR _dir$[esp+8]
	shr	eax, 22					; 00000016H
	cmp	DWORD PTR [edi+eax*4], 0
	lea	ebp, DWORD PTR [edi+eax*4]
	jne	SHORT $LN6@vmmngr_cre

; 209  : 		void* block = pmm_alloc_block();

	call	?pmm_alloc_block@@YAPAXXZ		; pmm_alloc_block
	mov	esi, eax

; 210  : 		if (!block)

	test	esi, esi
	jne	SHORT $LN1@vmmngr_cre
	pop	edi
	pop	esi
	pop	ebp

; 219  : }

	ret	0
$LN1@vmmngr_cre:
	push	ebx

; 211  : 			return 0; /* Should call debugger */
; 212  : 		pagedir[virt >> 22] = ((uint32_t)block) | flags;
; 213  : 		memset((uint32_t*)pagedir[virt >> 22], 0, 4096);

	push	4096					; 00001000H
	mov	ebx, esi
	or	ebx, DWORD PTR _flags$[esp+16]
	push	0
	push	ebx
	mov	DWORD PTR [ebp], ebx
	call	?memset@@YAPAXPAXDI@Z			; memset

; 214  : 
; 215  : 		/* map page table into directory */
; 216  : 		vmm_mapPhysicalAddress(dir, (uint32_t)block, (uint32_t)block, flags);

	mov	eax, esi
	add	esp, 12					; 0000000cH
	shr	eax, 22					; 00000016H
	cmp	DWORD PTR [edi+eax*4], 0
	lea	ebp, DWORD PTR [edi+eax*4]
	jne	SHORT $LN5@vmmngr_cre
	push	DWORD PTR _flags$[esp+12]
	push	esi
	push	edi
	call	?vmmngr_createPageTable@@YAHPAUpdir@@II@Z ; vmmngr_createPageTable
	add	esp, 12					; 0000000cH
$LN5@vmmngr_cre:
	mov	eax, DWORD PTR [ebp]
	shr	esi, 12					; 0000000cH
	and	esi, 1023				; 000003ffH
	and	eax, -4096				; fffff000H
	mov	DWORD PTR [eax+esi*4], ebx
	pop	ebx
$LN6@vmmngr_cre:

; 217  : 	}
; 218  : 	return 1; /* success */

	pop	edi
	pop	esi
	mov	eax, 1
	pop	ebp

; 219  : }

	ret	0
?vmmngr_createPageTable@@YAHPAUpdir@@II@Z ENDP		; vmmngr_createPageTable
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_mapPhysicalAddress@@YAXPAUpdir@@III@Z
_TEXT	SEGMENT
_dir$ = 8						; size = 4
_virt$ = 12						; size = 4
_phys$ = 16						; size = 4
_flags$ = 20						; size = 4
?vmm_mapPhysicalAddress@@YAXPAUpdir@@III@Z PROC		; vmm_mapPhysicalAddress, COMDAT

; 229  : 
; 230  : 	pd_entry* pagedir = dir->entry;
; 231  : 	if (pagedir[virt >> 22] == 0)

	mov	ecx, DWORD PTR _dir$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _virt$[esp+4]
	mov	eax, esi
	shr	eax, 22					; 00000016H
	cmp	DWORD PTR [ecx+eax*4], 0
	lea	ebx, DWORD PTR [ecx+eax*4]
	jne	SHORT $LN1@vmm_mapPhy

; 232  : 		vmmngr_createPageTable(dir, virt, flags);

	push	DWORD PTR _flags$[esp+4]
	push	esi
	push	ecx
	call	?vmmngr_createPageTable@@YAHPAUpdir@@II@Z ; vmmngr_createPageTable
	add	esp, 12					; 0000000cH
$LN1@vmm_mapPhy:

; 233  : 	((uint32_t*)(pagedir[virt >> 22] & ~0xfff))[virt << 10 >> 10 >> 12] = phys | flags;

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR _phys$[esp+4]
	and	eax, -4096				; fffff000H
	or	ecx, DWORD PTR _flags$[esp+4]
	shr	esi, 12					; 0000000cH
	and	esi, 1023				; 000003ffH
	mov	DWORD PTR [eax+esi*4], ecx
	pop	esi
	pop	ebx

; 234  : }

	ret	0
?vmm_mapPhysicalAddress@@YAXPAUpdir@@III@Z ENDP		; vmm_mapPhysicalAddress
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_initialize@@YAXXZ
_TEXT	SEGMENT
_dir$ = -8						; size = 4
_b$ = -4						; size = 1
?vmm_initialize@@YAXXZ PROC				; vmm_initialize, COMDAT

; 90   : void vmm_initialize(){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	edi

; 91   : 	ptable * pt_first4mb = (ptable *)pmm_alloc_block();

	call	?pmm_alloc_block@@YAPAXXZ		; pmm_alloc_block
	mov	edi, eax

; 92   : 	if (!pt_first4mb)

	test	edi, edi
	je	$LN17@vmm_initia

; 93   : 		return;
; 94   : 	ptable * pt_1mb_to_3gb = (ptable *)pmm_alloc_block();

	push	ebx
	call	?pmm_alloc_block@@YAPAXXZ		; pmm_alloc_block
	mov	ebx, eax

; 95   : 	if (!pt_1mb_to_3gb)

	test	ebx, ebx
	je	$LN31@vmm_initia

; 96   : 		return;
; 97   : 	/* Map 1st 4Mb (phys) to 1st 4Mb (virt) - identity map */
; 98   : 	for (uint32_t i = 0, frame = 0; i < 1024; i++, frame += 4096)

	push	esi
	xor	esi, esi
	xor	edx, edx
	npad	5
$LL23@vmm_initia:

; 99   : 		pt_first4mb->entry[i] = frame | VMM_PT_ENTRY_PRESENT;

	mov	ecx, esi
	add	esi, 4096				; 00001000H
	or	ecx, 1
	mov	DWORD PTR [edi+edx*4], ecx
	inc	edx
	cmp	edx, 1024				; 00000400H
	jb	SHORT $LL23@vmm_initia

; 100  : 
; 101  : 	for (uint32_t i = 0, frame = 0x100000; i < 1024; i++, frame += 4096)

	mov	edx, 1048576				; 00100000H
	xor	ecx, ecx
	npad	2
$LL25@vmm_initia:

; 102  : 		pt_1mb_to_3gb->entry[i] = frame | VMM_PT_ENTRY_PRESENT;

	mov	eax, edx
	add	edx, 4096				; 00001000H
	or	eax, 1
	mov	DWORD PTR [ebx+ecx*4], eax
	inc	ecx
	cmp	ecx, 1024				; 00000400H
	jb	SHORT $LL25@vmm_initia

; 103  : 
; 104  : 	/*set Page table to page directory*/
; 105  : 	pdir *dir = (pdir*)pmm_alloc_block();

	call	?pmm_alloc_block@@YAPAXXZ		; pmm_alloc_block
	mov	esi, eax

; 106  : 	if (!dir)

	test	esi, esi
	je	SHORT $LN32@vmm_initia

; 107  : 		return;
; 108  : 
; 109  : 	memset(dir, 0, sizeof(pdir));

	push	4096					; 00001000H
	push	0
	push	esi
	call	?memset@@YAPAXPAXDI@Z			; memset

; 110  : 	dir->entry[0] = (pd_entry)pt_first4mb | VMM_PT_ENTRY_PRESENT | VMM_PT_ENTRY_WRITABLE;

	or	edi, 3

; 111  : 	dir->entry[VMM_GET_PD_ENTRY(0xC0000000)] = (pt_entry)pt_1mb_to_3gb | VMM_PT_ENTRY_PRESENT | VMM_PT_ENTRY_WRITABLE;
; 112  : 
; 113  : 	/*Set Page Directory Base Address*/
; 114  : 	vmm_pd_switch(dir);

	mov	DWORD PTR __vmm_cur_dir, esi
	add	esp, 12					; 0000000cH
	mov	DWORD PTR [esi], edi
	or	ebx, 3
	mov	DWORD PTR _dir$[ebp], esi
	mov	DWORD PTR [esi+3072], ebx
	mov	eax, DWORD PTR _dir$[ebp]
	mov	cr3, eax

; 115  : 
; 116  : 	/* paging Enable */
; 117  : 	vmm_paging_enable(true);

	mov	BYTE PTR _b$[ebp], 1
	mov	eax, cr0
	cmp	BYTE PTR _b$[ebp], 1
	jne	SHORT $fal$34
	or	eax, -2147483648			; 80000000H
	jmp	SHORT $set$35
$fal$34:
	and	eax, 2147483647				; 7fffffffH
$set$35:
	mov	cr0, eax
$LN32@vmm_initia:
	pop	esi
$LN31@vmm_initia:
	pop	ebx
$LN17@vmm_initia:
	pop	edi

; 118  : 
; 119  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?vmm_initialize@@YAXXZ ENDP				; vmm_initialize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_map_page@@YAXPAX0@Z
_TEXT	SEGMENT
_phys$ = 8						; size = 4
_virt$ = 12						; size = 4
?vmm_map_page@@YAXPAX0@Z PROC				; vmm_map_page, COMDAT

; 63   : 	pdir *dir = _vmm_cur_dir;
; 64   : 	pd_entry *pde = (pd_entry *)&dir->entry[VMM_GET_PD_ENTRY((pd_entry)virt)];

	mov	eax, DWORD PTR __vmm_cur_dir
	push	ebx
	push	esi
	mov	esi, DWORD PTR _virt$[esp+4]
	mov	ecx, esi
	shr	ecx, 22					; 00000016H

; 65   : 	if (!(*pde&VMM_PT_ENTRY_PRESENT)){

	test	BYTE PTR [eax+ecx*4], 1
	push	edi
	lea	edi, DWORD PTR [eax+ecx*4]
	jne	SHORT $LN9@vmm_map_pa

; 66   : 		//! page table not present, allocate it
; 67   : 		ptable* table = (ptable*)pmm_alloc_block();

	call	?pmm_alloc_block@@YAPAXXZ		; pmm_alloc_block
	mov	ebx, eax

; 68   : 		if (!table)

	test	ebx, ebx
	je	SHORT $LN13@vmm_map_pa

; 69   : 			return;
; 70   : 
; 71   : 		//! clear page table
; 72   : 		memset(table, 0, sizeof(ptable));

	push	4096					; 00001000H
	push	0
	push	ebx
	call	?memset@@YAPAXPAXDI@Z			; memset

; 73   : 
; 74   : 		//! create a new entry
; 75   : 		pd_entry* entry = &dir->entry[VMM_GET_PD_ENTRY((uint32_t)virt)];
; 76   : 
; 77   : 		//! map in the table (Can also just do *entry |= 3) to enable these bits
; 78   : 		vmm_pd_entry_add_attrib(entry, VMM_PT_ENTRY_PRESENT);
; 79   : 		vmm_pd_entry_add_attrib(entry, VMM_PT_ENTRY_WRITABLE);
; 80   : 		vmm_pd_entry_set_frame(entry, (physical_addr)table);

	mov	eax, DWORD PTR [edi]
	add	esp, 12					; 0000000cH
	and	eax, -2147479553			; 80000fffH
	or	eax, ebx
	or	eax, 3
	mov	DWORD PTR [edi], eax
$LN9@vmm_map_pa:

; 81   : 
; 82   : 	}
; 83   : 	ptable *table = (ptable *)(*pde& ~0xfff);

	mov	eax, DWORD PTR [edi]
	and	eax, -4096				; fffff000H

; 84   : 	pt_entry *page = &table->entry[VMM_GET_PT_ENTRY((pt_entry)virt)];

	shr	esi, 12					; 0000000cH
	and	esi, 1023				; 000003ffH
	lea	ecx, DWORD PTR [eax+esi*4]

; 85   : 	vmm_pt_entry_set_frame(page, (physical_addr)phys);

	mov	eax, DWORD PTR [ecx]
	and	eax, -2147479553			; 80000fffH

; 86   : 	vmm_pt_entry_add_attrib(page, VMM_PT_ENTRY_PRESENT);

	or	eax, DWORD PTR _phys$[esp+8]
	or	eax, 1
	mov	DWORD PTR [ecx], eax
$LN13@vmm_map_pa:

; 87   : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?vmm_map_page@@YAXPAX0@Z ENDP				; vmm_map_page
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_free_frame@@YA_NPAI@Z
_TEXT	SEGMENT
_pe$ = 8						; size = 4
?vmm_free_frame@@YA_NPAI@Z PROC				; vmm_free_frame, COMDAT

; 56   : bool vmm_free_frame(pt_entry * pe){

	push	esi

; 57   : 	pmm_free_block(pe); /*Maybe this wrong because we send Address of entry ?*/

	mov	esi, DWORD PTR _pe$[esp]
	push	esi
	call	?pmm_free_block@@YAXPAX@Z		; pmm_free_block

; 58   : 	vmm_pt_entry_del_attrib(pe, VMM_PT_ENTRY_PRESENT);

	and	DWORD PTR [esi], -2			; fffffffeH
	add	esp, 4

; 59   : 	return true;

	mov	al, 1
	pop	esi

; 60   : }

	ret	0
?vmm_free_frame@@YA_NPAI@Z ENDP				; vmm_free_frame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_alloc_frame@@YA_NPAI@Z
_TEXT	SEGMENT
_pe$ = 8						; size = 4
?vmm_alloc_frame@@YA_NPAI@Z PROC			; vmm_alloc_frame, COMDAT

; 48   : 	void *p = pmm_alloc_block();

	call	?pmm_alloc_block@@YAPAXXZ		; pmm_alloc_block
	mov	edx, eax

; 49   : 	if (!p)

	test	edx, edx
	jne	SHORT $LN1@vmm_alloc_

; 50   : 		return false;

	xor	al, al

; 54   : }

	ret	0
$LN1@vmm_alloc_:

; 51   : 	vmm_pt_entry_set_frame(pe, (physical_addr)p);

	mov	ecx, DWORD PTR _pe$[esp-4]
	mov	eax, DWORD PTR [ecx]
	and	eax, -2147479553			; 80000fffH

; 52   : 	vmm_pt_entry_add_attrib(pe, VMM_PT_ENTRY_PRESENT);

	or	eax, edx
	or	eax, 1
	mov	DWORD PTR [ecx], eax

; 53   : 	return true;

	mov	al, 1

; 54   : }

	ret	0
?vmm_alloc_frame@@YA_NPAI@Z ENDP			; vmm_alloc_frame
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_get_cur_dir@@YAPAUpdir@@XZ
_TEXT	SEGMENT
?vmm_get_cur_dir@@YAPAUpdir@@XZ PROC			; vmm_get_cur_dir, COMDAT

; 44   : 	return _vmm_cur_dir;

	mov	eax, DWORD PTR __vmm_cur_dir

; 45   : }

	ret	0
?vmm_get_cur_dir@@YAPAUpdir@@XZ ENDP			; vmm_get_cur_dir
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\ali\desktop\mangos\systemcore\syscore\kernel\vmm.cpp
;	COMDAT ?vmm_load_pdbr@@YAXPAUpdir@@@Z
_TEXT	SEGMENT
_dir$ = 8						; size = 4
?vmm_load_pdbr@@YAXPAUpdir@@@Z PROC			; vmm_load_pdbr, COMDAT

; 138  : 	_asm {
; 139  : 		mov eax, dword ptr[dir]

	mov	eax, DWORD PTR _dir$[esp-4]

; 140  : 			mov cr3, eax

	mov	cr3, eax

; 141  : 	}
; 142  : }

	ret	0
?vmm_load_pdbr@@YAXPAUpdir@@@Z ENDP			; vmm_load_pdbr
_TEXT	ENDS
END
